{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Taller de docker \u00b6 Este taller forma parte de las actividades del Aula de Software Libre de la Universidad de C\u00f3rdoba . Info Se recomienda acudir al evento con tu propio port\u00e1til y con una distribuci\u00f3n GNU/Linux compatible con Docker : Ubuntu , Debian , Fedora o CentOS . Si no dispones de ordenador propio notif\u00edcalo a los organizaci\u00f3n en la web de la actividad. Warning Para evitar demoras innecesarias en el inicio de la actividad es necesario traer ya de casa Docker instalado. Para ello lee el cap\u00edtulo de Instalaci\u00f3n .","title":"Taller de docker"},{"location":"#taller-de-docker","text":"Este taller forma parte de las actividades del Aula de Software Libre de la Universidad de C\u00f3rdoba . Info Se recomienda acudir al evento con tu propio port\u00e1til y con una distribuci\u00f3n GNU/Linux compatible con Docker : Ubuntu , Debian , Fedora o CentOS . Si no dispones de ordenador propio notif\u00edcalo a los organizaci\u00f3n en la web de la actividad. Warning Para evitar demoras innecesarias en el inicio de la actividad es necesario traer ya de casa Docker instalado. Para ello lee el cap\u00edtulo de Instalaci\u00f3n .","title":"Taller de docker"},{"location":"containers/","text":"Contenedores \u00b6 Los contenedores son instancias de las im\u00e1genes que hemos creado o hemos descargado que se ejecutan de forma aislada. Listado \u00b6 La orden para ver el listado de contenedores del sistema es docker container ls o la forma abreviada docker ps . Si lo ejecutamos nos dar\u00e1 un listado vac\u00edo porque no hay ning\u00fan contenedor activo. Probemos con el par\u00e1metro --all o -a . $ docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 4bd76e08b07f wordpress \"docker-\u2026\" 11 minutes ago Exited (0) peaceful_murdock 69a3c34c224d hello-world \"/hello\" 18 minutes ago Exited (0) blissful_goldwasser Estos contenedores est\u00e1n parados y se pueden volver a ejecutar, con el mismo estado que tuviera el sistema de archivos cuando se detuvieron. Ejecutar comandos dentro de un contenedor \u00b6 Ya hemos usado docker run para crear e iniciar un contenedor. Tambi\u00e9n podemos usar este comando para ejecutar programas que est\u00e9n dentro del contenedor. Por ejemplo: docker run --name ubuntu_bash --rm -i -t ubuntu bash Info Las primeras versiones de Docker eran m\u00e1s limitadas, respecto a la creaci\u00f3n de objetos. As\u00ed que sali\u00f3 con comandos como docker start , docker stop , etc. relacionados con los contenedores. Cuando surgieron m\u00e1s objetos no hab\u00eda consistencia entre los comandos de otros objetos (como docker volumes ls ) y los de los contenedores. As\u00ed que se ha creado una jerarqu\u00eda nueva de subcomandos bajo el comando container que son equivalentes y se mantienen por compatibilidad: Antiguo Nuevo docker run docker container run docker start docker container start docker stop docker container stop docker rm docker container rm docker inspect docker container inspect docker exec docker container exec No hay m\u00e1s diferencia entre ellos que el nombre. Pero esta forma de ejecutar cosas, crea un nuevo contenedor. Si queremos ejecutar un comando en un contenedor que ya est\u00e9 iniciado, debemos usar docker container exec . Ejecuta lo siguiente en otro terminal (no cierres el anterior). docker exec -w /tmp ubuntu_bash touch my_file.sh El par\u00e1metro -w indica el directorio de trabajo, despu\u00e9s indicamos el contenedor donde queremos ejecutar el comando ( ubuntu_bash ) y por \u00faltimo el comando a ejecutar ( touch my_file.sh ). Si en el primer terminal ejecutamos un listado del directorio tmp: # ls /tmp my_file.sh Vemos como podemos modificar un contenedor ya iniciado con docker container exec . Pulsa Control+C en el primer terminal para cerrar y borrar el contenedor. Iniciar un contenedor \u00b6 Con docker container start podemos iniciar un contenedor parado: $ docker container start peaceful_murdock peaceful_murdock $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 4bd76e08b07f wordpress \"docker\u2026\" 14 minutes ago Up 0.0.0.0:8080->80/tcp peaceful_murdock Veremos que la web de instalaci\u00f3n de WordPress est\u00e1 de nuevo disponible. Solo que ahora el contenedor se ejecuta en segundo plano y no lo podemos detener como antes. Detener un contenedor \u00b6 Con docker container stop podemos detener un contenedor iniciado, indicando su id o su nombre $ docker container stop 4bd76e08b07f 4bd76e08b07f Tip Podemos hacer referencia a los contenedores por su ID o por su nombre. Borrar un contenedor \u00b6 Un contenedor detenido ocupa espacio. Si hemos dejado de necesitar un contenedor podemos borrarlo con docker container rm . Igualmente hay que indicar id o nombre. $ docker container rm 4bd76e08b07f 4bd76e08b07f Danger Hay que tener cuidado al borrar contenedores. Cuando un contenedor se borra se elimina cualquier informaci\u00f3n que contenga y no est\u00e9 almacenada en alg\u00fan lugar externo al propio contenedor.","title":"Contenedores"},{"location":"containers/#contenedores","text":"Los contenedores son instancias de las im\u00e1genes que hemos creado o hemos descargado que se ejecutan de forma aislada.","title":"Contenedores"},{"location":"containers/#listado","text":"La orden para ver el listado de contenedores del sistema es docker container ls o la forma abreviada docker ps . Si lo ejecutamos nos dar\u00e1 un listado vac\u00edo porque no hay ning\u00fan contenedor activo. Probemos con el par\u00e1metro --all o -a . $ docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 4bd76e08b07f wordpress \"docker-\u2026\" 11 minutes ago Exited (0) peaceful_murdock 69a3c34c224d hello-world \"/hello\" 18 minutes ago Exited (0) blissful_goldwasser Estos contenedores est\u00e1n parados y se pueden volver a ejecutar, con el mismo estado que tuviera el sistema de archivos cuando se detuvieron.","title":"Listado"},{"location":"containers/#ejecutar-comandos-dentro-de-un-contenedor","text":"Ya hemos usado docker run para crear e iniciar un contenedor. Tambi\u00e9n podemos usar este comando para ejecutar programas que est\u00e9n dentro del contenedor. Por ejemplo: docker run --name ubuntu_bash --rm -i -t ubuntu bash Info Las primeras versiones de Docker eran m\u00e1s limitadas, respecto a la creaci\u00f3n de objetos. As\u00ed que sali\u00f3 con comandos como docker start , docker stop , etc. relacionados con los contenedores. Cuando surgieron m\u00e1s objetos no hab\u00eda consistencia entre los comandos de otros objetos (como docker volumes ls ) y los de los contenedores. As\u00ed que se ha creado una jerarqu\u00eda nueva de subcomandos bajo el comando container que son equivalentes y se mantienen por compatibilidad: Antiguo Nuevo docker run docker container run docker start docker container start docker stop docker container stop docker rm docker container rm docker inspect docker container inspect docker exec docker container exec No hay m\u00e1s diferencia entre ellos que el nombre. Pero esta forma de ejecutar cosas, crea un nuevo contenedor. Si queremos ejecutar un comando en un contenedor que ya est\u00e9 iniciado, debemos usar docker container exec . Ejecuta lo siguiente en otro terminal (no cierres el anterior). docker exec -w /tmp ubuntu_bash touch my_file.sh El par\u00e1metro -w indica el directorio de trabajo, despu\u00e9s indicamos el contenedor donde queremos ejecutar el comando ( ubuntu_bash ) y por \u00faltimo el comando a ejecutar ( touch my_file.sh ). Si en el primer terminal ejecutamos un listado del directorio tmp: # ls /tmp my_file.sh Vemos como podemos modificar un contenedor ya iniciado con docker container exec . Pulsa Control+C en el primer terminal para cerrar y borrar el contenedor.","title":"Ejecutar comandos dentro de un contenedor"},{"location":"containers/#iniciar-un-contenedor","text":"Con docker container start podemos iniciar un contenedor parado: $ docker container start peaceful_murdock peaceful_murdock $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 4bd76e08b07f wordpress \"docker\u2026\" 14 minutes ago Up 0.0.0.0:8080->80/tcp peaceful_murdock Veremos que la web de instalaci\u00f3n de WordPress est\u00e1 de nuevo disponible. Solo que ahora el contenedor se ejecuta en segundo plano y no lo podemos detener como antes.","title":"Iniciar un contenedor"},{"location":"containers/#detener-un-contenedor","text":"Con docker container stop podemos detener un contenedor iniciado, indicando su id o su nombre $ docker container stop 4bd76e08b07f 4bd76e08b07f Tip Podemos hacer referencia a los contenedores por su ID o por su nombre.","title":"Detener un contenedor"},{"location":"containers/#borrar-un-contenedor","text":"Un contenedor detenido ocupa espacio. Si hemos dejado de necesitar un contenedor podemos borrarlo con docker container rm . Igualmente hay que indicar id o nombre. $ docker container rm 4bd76e08b07f 4bd76e08b07f Danger Hay que tener cuidado al borrar contenedores. Cuando un contenedor se borra se elimina cualquier informaci\u00f3n que contenga y no est\u00e9 almacenada en alg\u00fan lugar externo al propio contenedor.","title":"Borrar un contenedor"},{"location":"data/","text":"Persistiendo datos \u00b6 Por defecto ya hemos indicado que un contenedor est\u00e1 aislado de todo. Hemos visto como podemos conectar el contenedor a un puerto de red para poder acceder a \u00e9l. Eso incluye al sistema de archivos que contiene. De tal manera que si se elimina el contenedor, se eliminan tambi\u00e9n sus archivos. Si queremos almacenar datos (una web, una base de datos, etc.) dentro de un contenedor necesitamos una manera de almacenarlos sin perderlos. Docker ofrece tres maneras: A trav\u00e9s de vol\u00famenes, que son objetos de Docker como las im\u00e1genes y los contenedores. Montando un directorio de la m\u00e1quina anfitri\u00f3n dentro del contenedor. Almacen\u00e1ndolo en la memoria del sistema (aunque tambi\u00e9n se perder\u00edan al reiniciar el servidor). Lo normal es usar vol\u00famenes, pero habr\u00e1 ocasiones en que es preferible montar directamente un directorio de nuestro espacio de trabajo. Por ejemplo, para guardar los datos de una base de datos usaremos vol\u00famenes, pero para guardar el c\u00f3digo de una aplicaci\u00f3n o de una p\u00e1gina web montaremos el directorio. La raz\u00f3n para esto \u00faltimo es que tanto nuestro entorno de desarrollo como el contenedor tengan acceso a los archivos del c\u00f3digo fuente. Los vol\u00famenes, al contrario que los directorios montados, no deben accederse desde la m\u00e1quina anfitri\u00f3n. Crear un volumen \u00b6 Como necesitamos crear una base de datos para nuestro blog con WordPress vamos a crear un volumen donde guardar la informaci\u00f3n: $ docker volume create wordpress-db wordpress-db Listar vol\u00famenes \u00b6 Con docker volume ls podemos visualizar todos los volumenes disponibles. $ docker volume ls DRIVER VOLUME NAME local wordpress-db Visualizar vol\u00famenes \u00b6 Los volumenes se crean en un directorio del sistema y no es recomendable acceder a \u00e9l, no al menos mientras haya un contenedor us\u00e1ndolo. En cualquier caso, si queremos ver los metadatos de un volumen podemos usar docker volume inspect $ docker volume inspect wordpress-db [ { \"CreatedAt\": \"yyyy-mm-ddThh:ii:ss+Z\", \"Driver\": \"local\", \"Labels\": {}, \"Mountpoint\": \"/var/lib/docker/volumes/wordpress-db/_data\", \"Name\": \"wordpress-db\", \"Options\": {}, \"Scope\": \"local\" } ] Borrar volumenes \u00b6 Como todos los objetos de Docker , los vol\u00famenes tambi\u00e9n pueden ser borrados, pero solo si no est\u00e1n en uso. Mucha precauci\u00f3n al borrar los vol\u00famenes, porque perder\u00edamos todos los datos que contenga. Para borrar un contenedor usaremos docker volume rm y el nombre del contenedor.","title":"Persistiendo datos"},{"location":"data/#persistiendo-datos","text":"Por defecto ya hemos indicado que un contenedor est\u00e1 aislado de todo. Hemos visto como podemos conectar el contenedor a un puerto de red para poder acceder a \u00e9l. Eso incluye al sistema de archivos que contiene. De tal manera que si se elimina el contenedor, se eliminan tambi\u00e9n sus archivos. Si queremos almacenar datos (una web, una base de datos, etc.) dentro de un contenedor necesitamos una manera de almacenarlos sin perderlos. Docker ofrece tres maneras: A trav\u00e9s de vol\u00famenes, que son objetos de Docker como las im\u00e1genes y los contenedores. Montando un directorio de la m\u00e1quina anfitri\u00f3n dentro del contenedor. Almacen\u00e1ndolo en la memoria del sistema (aunque tambi\u00e9n se perder\u00edan al reiniciar el servidor). Lo normal es usar vol\u00famenes, pero habr\u00e1 ocasiones en que es preferible montar directamente un directorio de nuestro espacio de trabajo. Por ejemplo, para guardar los datos de una base de datos usaremos vol\u00famenes, pero para guardar el c\u00f3digo de una aplicaci\u00f3n o de una p\u00e1gina web montaremos el directorio. La raz\u00f3n para esto \u00faltimo es que tanto nuestro entorno de desarrollo como el contenedor tengan acceso a los archivos del c\u00f3digo fuente. Los vol\u00famenes, al contrario que los directorios montados, no deben accederse desde la m\u00e1quina anfitri\u00f3n.","title":"Persistiendo datos"},{"location":"data/#crear-un-volumen","text":"Como necesitamos crear una base de datos para nuestro blog con WordPress vamos a crear un volumen donde guardar la informaci\u00f3n: $ docker volume create wordpress-db wordpress-db","title":"Crear un volumen"},{"location":"data/#listar-volumenes","text":"Con docker volume ls podemos visualizar todos los volumenes disponibles. $ docker volume ls DRIVER VOLUME NAME local wordpress-db","title":"Listar vol\u00famenes"},{"location":"data/#visualizar-volumenes","text":"Los volumenes se crean en un directorio del sistema y no es recomendable acceder a \u00e9l, no al menos mientras haya un contenedor us\u00e1ndolo. En cualquier caso, si queremos ver los metadatos de un volumen podemos usar docker volume inspect $ docker volume inspect wordpress-db [ { \"CreatedAt\": \"yyyy-mm-ddThh:ii:ss+Z\", \"Driver\": \"local\", \"Labels\": {}, \"Mountpoint\": \"/var/lib/docker/volumes/wordpress-db/_data\", \"Name\": \"wordpress-db\", \"Options\": {}, \"Scope\": \"local\" } ]","title":"Visualizar vol\u00famenes"},{"location":"data/#borrar-volumenes","text":"Como todos los objetos de Docker , los vol\u00famenes tambi\u00e9n pueden ser borrados, pero solo si no est\u00e1n en uso. Mucha precauci\u00f3n al borrar los vol\u00famenes, porque perder\u00edamos todos los datos que contenga. Para borrar un contenedor usaremos docker volume rm y el nombre del contenedor.","title":"Borrar volumenes"},{"location":"docker-compose/","text":"Levantar un WordPress con Docker Compose \u00b6 El cliente de Docker es engorroso para crear contenedores, as\u00ed como para crear el resto de objetos y vincularlos entre s\u00ed. Para automatizar la creaci\u00f3n, inicio y parada de un contenedor o un conjunto de ellos, Docker proporciona una herramiento llamada Docker Compose . Para esta parte vamos a detener y borrar lo que hemos creado: Example Borra el trabajo actual: docker container stop wordpress wordpress-db docker container rm wordpress wordpress-db docker volume rm wordpress-db Docker Compose \u00b6 Compose es una herramienta para definir y ejecutar aplicaciones multi-contenedor. Con un solo comando podremos crear e iniciar todos los servicios que necesitamos para nuestra aplicaci\u00f3n. Los casos de uso m\u00e1s habituales para docker-compose son: Entornos de desarrollo Entornos de testeo autom\u00e1ticos (integraci\u00f3n cont\u00ednua) Despliegue en host individuales (no clusters) Compose tiene comandos para manejar todo el ciclo de vida de nuestra aplicaci\u00f3n: Iniciar, detener y rehacer servicios. Ver el estado de los servicios. Visualizar los logs. Ejecutar un comando en un servicio. Creaci\u00f3n de contenedores automatizada \u00b6 En el mismo directorio donde est\u00e1bamos en el paso anterior ( ~/Sites/wordpress ), vamos a crear un fichero llamado docker-compose.yaml con el siguiente contenido: version : '3' services : db : image : mariadb:10.3.9 volumes : - data:/var/lib/mysql environment : - MYSQL_ROOT_PASSWORD=secret - MYSQL_DATABASE=wordpress - MYSQL_USER=manager - MYSQL_PASSWORD=secret web : image : wordpress:4.9.8 depends_on : - db volumes : - ./target:/var/www/html environment : - WORDPRESS_DB_USER=manager - WORDPRESS_DB_PASSWORD=secret - WORDPRESS_DB_HOST=db ports : - 8080:80 volumes : data : Info YAML es un lenguaje de serializaci\u00f3n de datos dise\u00f1ado para ser le\u00eddo y escrito por personas. Se recomienda que sigas alg\u00fan tutorial para entender su formato: Aprende YAML en Y minutos . Los ficheros de Compose est\u00e1n divididos en tres secciones: services , volumes y networks ; y deben indicar un n\u00famero de versi\u00f3n. Nos permite realizar practicamente lo mismo que podemos hacer con el cliente de docker , pero de forma autom\u00e1tica. Note En este taller no entramos en el apartado de networks . Con este fichero podemos hacer lo mismo que hemos hecho en el cap\u00edtulo anterior, pero con la ventaja de describir todos nuestros requisitos en un solo archivo. Iniciar servicios \u00b6 Vamos a ejecutar esta aplicaci\u00f3n y luego procederemos a explicarla: Example Arranca la aplicaci\u00f3n con Compose : docker-compose up -d Cuando arrancamos la aplicaci\u00f3n, Compose nos informa de los servicios que ha ido levantando: $ docker-compose up -d Creating network \"wordpress_default\" with the default driver Creating volume \"wordpress_data\" with local driver Creating wordpress_db_1 ... Creating wordpress_db_1 ... done Creating wordpress_web_1 ... Creating wordpress_web_1 ... done El par\u00e1metro -d es similar al que hemos visto en docker run : nos permite levantar los servicios en segundo plano. Veamos los contenedores activos: $ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES a07b5d4d3982 wordpress:4.9.8 \"docker.s\u2026\" 10 seconds ago Up 8 seconds 0.0.0.0:8080->80/tcp wordpress_web_1 d9204884cec5 mariadb:10.3.9 \"docker.s\u2026\" 11 seconds ago Up 10 seconds 3306/tcp wordpress_db_1 Tambi\u00e9n podemos ver los contenedores con Compose : $ docker-compose ps Name Command State Ports ------------------------------------------------------------------------------- wordpress_db_1 docker-entrypoint.sh mysqld Up 3306/tcp wordpress_web_1 docker-entrypoint.sh apach ... Up 0.0.0.0:8080->80/tcp Lo que tenemos que tener en cuenta es lo siguiente: docker-compose ps solo muestra informaci\u00f3n de los servicios que se define en docker-compose.yaml , mientras que docker muestra todos. Cuando creamos contenedores con docker sin indicar un nombre, por defecto asigna uno aleatorio; mientras que en Compose el prefijo es el nombre del directorio y el sufijo el nombre del servicio: wordpress _ db _1 . El n\u00famero indica el n\u00famero de instancia. Es posible levantar m\u00e1s de una instancia de un mismo servicio. Si accedemos a la direcci\u00f3n http://localhost:8080/ , veremos de nuevo la instalaci\u00f3n de WordPress. Detener servicios \u00b6 Podemos detener servicios con docker-compose stop Borrar servicios \u00b6 Podemos borrar servicios con docker-compose down Esto borra los contenedores, pero no los vol\u00famenes. As\u00ed que si hemos creado bien la aplicaci\u00f3n nuestros datos est\u00e1n a salvo. Si queremos borrar tambi\u00e9n los vol\u00famenes: docker-compose down -v Estructura de la configuraci\u00f3n \u00b6 Veamos la configuraci\u00f3n por partes: version : '3' Compose se actualiza a menudo, con lo que el archivo de configuraci\u00f3n va adquiriendo nuevas funcionalidades. La versi\u00f3n '3' (es una cadena, importante poner comillas) es la \u00faltima y para conocer todas sus caracter\u00edsticas mira la p\u00e1gina de referencia de la versi\u00f3n 3 de Compose . volumes : data : Ya hemos indicado que es importante guardar los datos vol\u00e1tiles de las aplicaciones en vol\u00famenes. En este caso hemos creado un volumen llamado data . Recordemos que Compose siempre a\u00f1ade como prefijo el nombre del directorio, con lo que el nombre real del volumen es wordpress_data . Podemos comprobarlo con el cliente de docker como hicimos en el cap\u00edtulo de vol\u00famenes: $ docker volume ls DRIVER VOLUME NAME local wordpress_data Nos saltamos la secci\u00f3n de redes ( networks ) y vamos a la secci\u00f3n de servicios, que son los contenedores que precisa o componen nuestra aplicaci\u00f3n. Primero la base de datos: services : db : image : mariadb:10.3.9 volumes : - data:/var/lib/mysql environment : - MYSQL_ROOT_PASSWORD=secret - MYSQL_DATABASE=wordpress - MYSQL_USER=manager - MYSQL_PASSWORD=secret Despu\u00e9s de abrir la parte de servicios, el primer nivel indica el nombre del servicio db , que genera el contenedor wordpress_db . Lo que vemos a continuaci\u00f3n es lo mismo que hicimos en la secci\u00f3n anterior pero de forma parametrizada. Si recordamos, para levantar nuestra base de datos, indicamos la imagen (l\u00ednea 3), luego montamos los vol\u00famenes (l\u00ednea 4), y despu\u00e9s indicamos las variables de entorno que configuraban el contenedor (l\u00ednea 6). Es decir, lo anterior es equivalente, excepto por el nombre, a: $ docker run -d --name wordpress-db \\ --mount source=wordpress-db,target=/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=secret \\ -e MYSQL_DATABASE=wordpress \\ -e MYSQL_USER=manager \\ -e MYSQL_PASSWORD=secret mariadb:10.3.9 Y despu\u00e9s nuestro WordPress : services : web : image : wordpress:4.9.8 depends_on : - db volumes : - ./target:/var/www/html environment : - WORDPRESS_DB_USER=manager - WORDPRESS_DB_PASSWORD=secret - WORDPRESS_DB_HOST=db ports : - 8080:80 En este caso la equivalencia es al comando: $ docker run -d --name wordpress \\ --link wordpress-db:mysql \\ --mount type=bind,source=\"$(pwd)\"/target,target=/var/www/html \\ -e WORDPRESS_DB_USER=manager \\ -e WORDPRESS_DB_PASSWORD=secret \\ -p 8080:80 \\ wordpress:4.9.8 La equivalencia de los par\u00e1metros es la siguiente: par\u00e1metro Docker par\u00e1metro Composer --link depends_on --mount volumes -e environment -p,--publish ports image Note Si reiniciamos el ordenador, los contenedores estar\u00e1n detenidos (stop), podremos reiniciarlos con docker start o docker-compose start . Este es el comportamiento predeterminado y el que nos interesa en un entorno de desarrollo. Sin embargo, en otros entornos, o para casos concretos, igual queremos que un contenedor tenga el mismo estado en el que estaba antes de reiniciar la m\u00e1quina (iniciado o parado). Para eso usaremos el par\u00e1metro restart . En el caso de la base de datos de nuestro ejemplo, la configuraci\u00f3n quedar\u00eda como: services : db : image : mariadb:10.3.9 restart : unless-stopped volumes : - data:/var/lib/mysql environment : - MYSQL_ROOT_PASSWORD=secret - MYSQL_DATABASE=wordpress - MYSQL_USER=manager - MYSQL_PASSWORD=secret El equivalente en la consola ser\u00eda: $ docker run -d --name wordpress-db \\ --restart unless-stopped --mount source=wordpress-db,target=/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=secret \\ -e MYSQL_DATABASE=wordpress \\ -e MYSQL_USER=manager \\ -e MYSQL_PASSWORD=secret mariadb:10.3.9 Otros valores son: no (por defecto), always y on-failure .","title":"Levantar un WordPress con Docker Compose"},{"location":"docker-compose/#levantar-un-wordpress-con-docker-compose","text":"El cliente de Docker es engorroso para crear contenedores, as\u00ed como para crear el resto de objetos y vincularlos entre s\u00ed. Para automatizar la creaci\u00f3n, inicio y parada de un contenedor o un conjunto de ellos, Docker proporciona una herramiento llamada Docker Compose . Para esta parte vamos a detener y borrar lo que hemos creado: Example Borra el trabajo actual: docker container stop wordpress wordpress-db docker container rm wordpress wordpress-db docker volume rm wordpress-db","title":"Levantar un WordPress con Docker Compose"},{"location":"docker-compose/#docker-compose","text":"Compose es una herramienta para definir y ejecutar aplicaciones multi-contenedor. Con un solo comando podremos crear e iniciar todos los servicios que necesitamos para nuestra aplicaci\u00f3n. Los casos de uso m\u00e1s habituales para docker-compose son: Entornos de desarrollo Entornos de testeo autom\u00e1ticos (integraci\u00f3n cont\u00ednua) Despliegue en host individuales (no clusters) Compose tiene comandos para manejar todo el ciclo de vida de nuestra aplicaci\u00f3n: Iniciar, detener y rehacer servicios. Ver el estado de los servicios. Visualizar los logs. Ejecutar un comando en un servicio.","title":"Docker Compose"},{"location":"docker-compose/#creacion-de-contenedores-automatizada","text":"En el mismo directorio donde est\u00e1bamos en el paso anterior ( ~/Sites/wordpress ), vamos a crear un fichero llamado docker-compose.yaml con el siguiente contenido: version : '3' services : db : image : mariadb:10.3.9 volumes : - data:/var/lib/mysql environment : - MYSQL_ROOT_PASSWORD=secret - MYSQL_DATABASE=wordpress - MYSQL_USER=manager - MYSQL_PASSWORD=secret web : image : wordpress:4.9.8 depends_on : - db volumes : - ./target:/var/www/html environment : - WORDPRESS_DB_USER=manager - WORDPRESS_DB_PASSWORD=secret - WORDPRESS_DB_HOST=db ports : - 8080:80 volumes : data : Info YAML es un lenguaje de serializaci\u00f3n de datos dise\u00f1ado para ser le\u00eddo y escrito por personas. Se recomienda que sigas alg\u00fan tutorial para entender su formato: Aprende YAML en Y minutos . Los ficheros de Compose est\u00e1n divididos en tres secciones: services , volumes y networks ; y deben indicar un n\u00famero de versi\u00f3n. Nos permite realizar practicamente lo mismo que podemos hacer con el cliente de docker , pero de forma autom\u00e1tica. Note En este taller no entramos en el apartado de networks . Con este fichero podemos hacer lo mismo que hemos hecho en el cap\u00edtulo anterior, pero con la ventaja de describir todos nuestros requisitos en un solo archivo.","title":"Creaci\u00f3n de contenedores automatizada"},{"location":"docker-compose/#iniciar-servicios","text":"Vamos a ejecutar esta aplicaci\u00f3n y luego procederemos a explicarla: Example Arranca la aplicaci\u00f3n con Compose : docker-compose up -d Cuando arrancamos la aplicaci\u00f3n, Compose nos informa de los servicios que ha ido levantando: $ docker-compose up -d Creating network \"wordpress_default\" with the default driver Creating volume \"wordpress_data\" with local driver Creating wordpress_db_1 ... Creating wordpress_db_1 ... done Creating wordpress_web_1 ... Creating wordpress_web_1 ... done El par\u00e1metro -d es similar al que hemos visto en docker run : nos permite levantar los servicios en segundo plano. Veamos los contenedores activos: $ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES a07b5d4d3982 wordpress:4.9.8 \"docker.s\u2026\" 10 seconds ago Up 8 seconds 0.0.0.0:8080->80/tcp wordpress_web_1 d9204884cec5 mariadb:10.3.9 \"docker.s\u2026\" 11 seconds ago Up 10 seconds 3306/tcp wordpress_db_1 Tambi\u00e9n podemos ver los contenedores con Compose : $ docker-compose ps Name Command State Ports ------------------------------------------------------------------------------- wordpress_db_1 docker-entrypoint.sh mysqld Up 3306/tcp wordpress_web_1 docker-entrypoint.sh apach ... Up 0.0.0.0:8080->80/tcp Lo que tenemos que tener en cuenta es lo siguiente: docker-compose ps solo muestra informaci\u00f3n de los servicios que se define en docker-compose.yaml , mientras que docker muestra todos. Cuando creamos contenedores con docker sin indicar un nombre, por defecto asigna uno aleatorio; mientras que en Compose el prefijo es el nombre del directorio y el sufijo el nombre del servicio: wordpress _ db _1 . El n\u00famero indica el n\u00famero de instancia. Es posible levantar m\u00e1s de una instancia de un mismo servicio. Si accedemos a la direcci\u00f3n http://localhost:8080/ , veremos de nuevo la instalaci\u00f3n de WordPress.","title":"Iniciar servicios"},{"location":"docker-compose/#detener-servicios","text":"Podemos detener servicios con docker-compose stop","title":"Detener servicios"},{"location":"docker-compose/#borrar-servicios","text":"Podemos borrar servicios con docker-compose down Esto borra los contenedores, pero no los vol\u00famenes. As\u00ed que si hemos creado bien la aplicaci\u00f3n nuestros datos est\u00e1n a salvo. Si queremos borrar tambi\u00e9n los vol\u00famenes: docker-compose down -v","title":"Borrar servicios"},{"location":"docker-compose/#estructura-de-la-configuracion","text":"Veamos la configuraci\u00f3n por partes: version : '3' Compose se actualiza a menudo, con lo que el archivo de configuraci\u00f3n va adquiriendo nuevas funcionalidades. La versi\u00f3n '3' (es una cadena, importante poner comillas) es la \u00faltima y para conocer todas sus caracter\u00edsticas mira la p\u00e1gina de referencia de la versi\u00f3n 3 de Compose . volumes : data : Ya hemos indicado que es importante guardar los datos vol\u00e1tiles de las aplicaciones en vol\u00famenes. En este caso hemos creado un volumen llamado data . Recordemos que Compose siempre a\u00f1ade como prefijo el nombre del directorio, con lo que el nombre real del volumen es wordpress_data . Podemos comprobarlo con el cliente de docker como hicimos en el cap\u00edtulo de vol\u00famenes: $ docker volume ls DRIVER VOLUME NAME local wordpress_data Nos saltamos la secci\u00f3n de redes ( networks ) y vamos a la secci\u00f3n de servicios, que son los contenedores que precisa o componen nuestra aplicaci\u00f3n. Primero la base de datos: services : db : image : mariadb:10.3.9 volumes : - data:/var/lib/mysql environment : - MYSQL_ROOT_PASSWORD=secret - MYSQL_DATABASE=wordpress - MYSQL_USER=manager - MYSQL_PASSWORD=secret Despu\u00e9s de abrir la parte de servicios, el primer nivel indica el nombre del servicio db , que genera el contenedor wordpress_db . Lo que vemos a continuaci\u00f3n es lo mismo que hicimos en la secci\u00f3n anterior pero de forma parametrizada. Si recordamos, para levantar nuestra base de datos, indicamos la imagen (l\u00ednea 3), luego montamos los vol\u00famenes (l\u00ednea 4), y despu\u00e9s indicamos las variables de entorno que configuraban el contenedor (l\u00ednea 6). Es decir, lo anterior es equivalente, excepto por el nombre, a: $ docker run -d --name wordpress-db \\ --mount source=wordpress-db,target=/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=secret \\ -e MYSQL_DATABASE=wordpress \\ -e MYSQL_USER=manager \\ -e MYSQL_PASSWORD=secret mariadb:10.3.9 Y despu\u00e9s nuestro WordPress : services : web : image : wordpress:4.9.8 depends_on : - db volumes : - ./target:/var/www/html environment : - WORDPRESS_DB_USER=manager - WORDPRESS_DB_PASSWORD=secret - WORDPRESS_DB_HOST=db ports : - 8080:80 En este caso la equivalencia es al comando: $ docker run -d --name wordpress \\ --link wordpress-db:mysql \\ --mount type=bind,source=\"$(pwd)\"/target,target=/var/www/html \\ -e WORDPRESS_DB_USER=manager \\ -e WORDPRESS_DB_PASSWORD=secret \\ -p 8080:80 \\ wordpress:4.9.8 La equivalencia de los par\u00e1metros es la siguiente: par\u00e1metro Docker par\u00e1metro Composer --link depends_on --mount volumes -e environment -p,--publish ports image Note Si reiniciamos el ordenador, los contenedores estar\u00e1n detenidos (stop), podremos reiniciarlos con docker start o docker-compose start . Este es el comportamiento predeterminado y el que nos interesa en un entorno de desarrollo. Sin embargo, en otros entornos, o para casos concretos, igual queremos que un contenedor tenga el mismo estado en el que estaba antes de reiniciar la m\u00e1quina (iniciado o parado). Para eso usaremos el par\u00e1metro restart . En el caso de la base de datos de nuestro ejemplo, la configuraci\u00f3n quedar\u00eda como: services : db : image : mariadb:10.3.9 restart : unless-stopped volumes : - data:/var/lib/mysql environment : - MYSQL_ROOT_PASSWORD=secret - MYSQL_DATABASE=wordpress - MYSQL_USER=manager - MYSQL_PASSWORD=secret El equivalente en la consola ser\u00eda: $ docker run -d --name wordpress-db \\ --restart unless-stopped --mount source=wordpress-db,target=/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=secret \\ -e MYSQL_DATABASE=wordpress \\ -e MYSQL_USER=manager \\ -e MYSQL_PASSWORD=secret mariadb:10.3.9 Otros valores son: no (por defecto), always y on-failure .","title":"Estructura de la configuraci\u00f3n"},{"location":"dockerfile/","text":"Crear im\u00e1genes propias \u00b6 Ya hemos visto como usar im\u00e1genes de terceros para crear aplicaciones y servicios. Pero, \u00bfsi no hay ninguna imagen que tenga lo que queremos? \u00bfO si queremos hacer una imagen de nuestra aplicaci\u00f3n para distribuirla? Docker permite crear imagenes propias. Aunque podr\u00edamos hacerla partiendo de cero, es un esfuerzo que no tiene sentido. Existe ya im\u00e1genes base para crear las nuestras y es mucho m\u00e1s f\u00e1cil crear una imagen bas\u00e1ndose en otra que hacerlo todo nosotros. Podemos partir de una imagen base que parte de un lenguaje de programaci\u00f3n ( python , php ) o de alguna distribuci\u00f3n ( ubuntu , debian ). Mi primer Dockerfile \u00b6 Los Dockerfile son los archivos que contienen las instrucciones que crean las imagenes. Deben estar guardados dentro de un build context , es decir, un directorio. Este directorio es el que contiene todos los archivos necesarios para construir nuestra imagen, de ah\u00ed lo de build context . Creamos nuestro build context mkdir -p ~/Sites/hello-world cd ~/Sites/hello-world echo \"hello\" > hello Dentro de este directorio crearemos un archivo llamado Dockerfile con este contenido: FROM busybox COPY /hello / RUN cat /hello Directiva Explicaci\u00f3n FROM Indica la imagen base sobre la que se basa esta imagen COPY Copia un archivo del build context y lo guarda en la imagen RUN Ejecuta el comando indicado durante el proceso de creaci\u00f3n de imagen. Ahora para crear nuestra imagen usaremos docker build . docker build -t helloapp:v1 . El par\u00e1metro -t nos permite etiquetar la imagen con un nombre y una versi\u00f3n. El . indica que el build context es el directorio actual. El resultado de ejecutar lo anterior ser\u00eda: $ docker build -t helloapp:v1 . Sending build context to Docker daemon 3.072kB Step 1/3 : FROM busybox latest: Pulling from library/busybox 8c5a7da1afbc: Pull complete Digest: sha256:cb63aa0641a885f54de20f61d152187419e8f6b159ed11a251a09d115fdff9bd Status: Downloaded newer image for busybox:latest ---> e1ddd7948a1c Step 2/3 : COPY /hello / ---> 8a092965dbc9 Step 3/3 : RUN cat /hello ---> Running in 83b5498790ca hello Removing intermediate container 83b5498790ca ---> f738f117d4b6 Successfully built f738f117d4b6 Successfully tagged helloapp:v1 Y podremos ver que una nueva imagen est\u00e1 instalada en nuestro equipo: $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE helloapp v1 f738f117d4b6 40 seconds ago 1.16MB Creando aplicaciones en contenedores \u00b6 Vamos a crear un aplicaci\u00f3n en python y la vamos a guardarla en un contenedor. Comenzamos creando un nuevo build context : mkdir -p ~/Sites/friendlyhello cd ~/Sites/friendlyhello El c\u00f3digo de la aplicaci\u00f3n es el siguiente, lo guardaremos en un archivo llamado app.py : from flask import Flask from redis import Redis , RedisError import os import socket # Connect to Redis redis = Redis ( host = \"redis\" , db = 0 , socket_connect_timeout = 2 , socket_timeout = 2 ) app = Flask ( __name__ ) @app . route ( \"/\" ) def hello (): try : visits = redis . incr ( \"counter\" ) except RedisError : visits = \"<i>cannot connect to Redis, counter disabled</i>\" html = \"<h3>Hello {name} !</h3>\" \\ \"<b>Hostname:</b> {hostname} <br/>\" \\ \"<b>Visits:</b> {visits} \" return html . format ( name = os . getenv ( \"NAME\" , \"world\" ), hostname = socket . gethostname (), visits = visits ) if __name__ == \"__main__\" : app . run ( host = '0.0.0.0' , port = 80 ) Nuestra aplicaci\u00f3n tiene una serie de dependencias (librer\u00edas de terceros) que guardaremos en el archivo requirements.txt : Flask Redis Y por \u00faltimo definimos nuestro Dockerfile : # Partimos de una base oficial de python FROM python:2.7-slim # El directorio de trabajo es desde donde se ejecuta el contenedor al iniciarse WORKDIR /app # Copiamos todos los archivos del build context al directorio /app del contenedor COPY . /app # Ejecutamos pip para instalar las dependencias en el contenedor RUN pip install --trusted-host pypi.python.org -r requirements.txt # Indicamos que este contenedor se comunica por el puerto 80/tcp EXPOSE 80 # Declaramos una variable de entorno ENV NAME World # Ejecuta nuestra aplicaci\u00f3n cuando se inicia el contenedor CMD [\"python\", \"app.py\"] Para conocer todas las directivas visita la documentaci\u00f3n oficial de Dockerfile . En total debemos tener 3 archivos: $ ls app.py Dockerfile requirements.txt Ahora construimos la imagen de nuestra aplicaci\u00f3n: docker build -t friendlyhello . Y comprobamos que est\u00e1 creada: $ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE friendlyhello latest 88a822b3107c 56 seconds ago 132MB Probar nuestro contenedor \u00b6 Vamos a arrancar nuestro contenedor y probar la aplicaci\u00f3n: docker run --rm -p 4000:80 friendlyhello Tip Normalmente los contenedores son de usar y tirar, sobre todo cuando hacemos pruebas. El par\u00e1metro --rm borra autom\u00e1ticamente un contenedor cuando se para. Recordemos que los datos vol\u00e1tiles siempre se deben guardar en vol\u00famenes. Lo que arranca la aplicaci\u00f3n Flask: $ docker run --rm -p 4000:80 friendlyhello * Serving Flask app \"app\" (lazy loading) * Environment: production WARNING: Do not use the development server in a production environment. Use a production WSGI server instead. * Debug mode: off * Running on http://0.0.0.0:80/ (Press CTRL+C to quit) Comprobamos en el puerto 4000 si efectivamente est\u00e1 iniciada o no: http://localhost:4000 . Obtendremos un mensaje como este: Hello World! Hostname: 0367b056e66e Visits: cannot connect to Redis, counter disabled Ya tenemos una imagen lista para ser usada. Pulsamos Control+C para interrumpir y borrar nuestro contenedor. Creando la aplicaci\u00f3n \u00b6 En este caso nuestro contenedor no funciona por s\u00ed mismo. Es muy habitual que dependamos de servicios para poder iniciar la aplicaci\u00f3n, habitualmente bases de datos. En este caso necesitamos una base de datos Redis que no tenemos. Como vimos en el apartado anterior, vamos a aprovechar las caracter\u00edsticas de Compose para levantar nuestra aplicaci\u00f3n. Vamos a crear el siguiente archivo docker-compose.yaml : version : \"3\" services : web : build : . ports : - \"4000:80\" redis : image : redis ports : - \"6379:6379\" volumes : - \"./data:/data\" command : redis-server --appendonly yes La principal diferencia con respecto al cap\u00edtulo anterior, es que en un servicio podemos indicar una imagen (par\u00e1metro imagen ) o un build context (par\u00e1metro build ). Esta es una manera de integrar las dos herramientas que nos proporciona Docker : la creaci\u00f3n de im\u00e1genes y la composici\u00f3n de aplicaciones con servicios. Balanceo de carga \u00b6 Vamos a modificar nuestro docker-compose.yaml : version: \"3\" services: web: build: . redis: image: redis volumes: - \"./data:/data\" command: redis-server --appendonly yes lb: image: dockercloud/haproxy ports: - 4000:80 links: - web volumes: - /var/run/docker.sock:/var/run/docker.sock En este caso, el servicio web no va a tener acceso al exterior (hemos eliminado el par\u00e1metro ports ). En su lugar hemos a\u00f1adido un balanceador de carga (el servicio lb ). Vamos a arrancar esta nueva aplicaci\u00f3n, pero esta vez a\u00f1adiendo varios servicios web: docker-composer up -d --scale web=5 Esperamos a que terminen de iniciar los servicios: $ docker-compose up -d --scale web=5 Creating network \"friendlyhello_default\" with the default driver Creating friendlyhello_redis_1 ... done Creating friendlyhello_web_1 ... done Creating friendlyhello_web_2 ... done Creating friendlyhello_web_3 ... done Creating friendlyhello_web_4 ... done Creating friendlyhello_web_5 ... done Creating friendlyhello_lb_1 ... done Podemos comprobar como del servicio web nos ha iniciado 5 instancias, cada uno con su sufijo num\u00e9rico correspondiente. Si usamos docker ps para ver los contenedores disponibles tendremos: $ docker ps CONTAINER ID IMAGE [...] PORTS NAMES 77acae1d0567 dockercloud/haproxy [...] 443/tcp, 1936/tcp, 0.0.0.0:4000->80/tcp friendlyhello_lb_1 5f12fb8b80c8 friendlyhello_web [...] 80/tcp friendlyhello_web_5 fb0024591665 friendlyhello_web [...] 80/tcp friendlyhello_web_2 a20d20bdd129 friendlyhello_web [...] 80/tcp friendlyhello_web_4 53d7db212df8 friendlyhello_web [...] 80/tcp friendlyhello_web_3 41218dbbb882 friendlyhello_web [...] 80/tcp friendlyhello_web_1 06f5bf6ed070 redis [...] 6379/tcp friendlyhello_redis_1 Vamos a fijarnos en el CONTAINER ID y vamos a volver a abrir nuestra aplicaci\u00f3n: http://localhost:4000 . Si en esta ocasi\u00f3n vamos recargando la p\u00e1gina, veremos como cambian los hostnames , que a su vez coinciden con los identificadores de los contenedores anteriores. Info Esta no es la manera adecuada de hacer balanceo de carga, puesto que todos los contenedores est\u00e1n en la misma m\u00e1quina, lo cual no tiene sentido. Solo es una demostraci\u00f3n. Para hacer balanceo de carga real necesitar\u00edamos tener o emular un clustes de m\u00e1quinas y crear un enjambre ( swarm ). Compartir im\u00e1genes \u00b6 Si tenemos una imagen que queramos compartir, necesitamos usar un registro. Existe incluso una imagen que nos permite crear uno propio, pero vamos a usar el repositorio p\u00fablico de Docker . Los pasos son: Crear una cuenta de usuario en el repositorio oficial de Docker . Pulsar sobre el bot\u00f3n \" Create Repository + \". En el formulario hay que rellenar solo un dato obligatoriamente: el nombre. Usaremos el de la imagen: friendlyhello . Nuestro nombre de usuario es el namespace y es obligatorio que tenga uno. Si estuvieramos en alguna organizaci\u00f3n podr\u00edamos elegir entre varios. El resto de campos lo dejamos como est\u00e1 por el momento. La cuenta gratuita solo deja tener un repositorio privado, asi que no lo malgastaremos aqu\u00ed. Ahora tenemos que conectar nuestro cliente de Docker con nuestra cuenta en el Hub . Usamos el comando docker login . $ docker login Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one. Username: username Password: ******** WARNING! Your password will be stored unencrypted in /home/sergio/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Danger Las claves se guardan sin cifrar. Hay que configurar un almacen de claves o recordar hacer docker logout para borrarla. Visita la web de referencia para saber como crear un almacen . Para que las im\u00e1genes se puedan guardar, tenemos que etiquetarla con el mismo nombre que tengamos en nuestro repositorio m\u00e1s el namespace . Si nuestra cuenta es ' username ' y el repositorio es ' friendlyhello ', debemos crear la imagen con la etiqueta ' username/friendlyhello '. $ docker build -t username/friendlyhello . Tip Por defecto ya hemos dicho que la etiqueta si no se indica es latest . Podemos indicar m\u00e1s de una etiqueta para indicar versiones: $ docker build -t username/friendlyhello -t username/friendlyhello:0.1.0 . En la pr\u00f3xima que hagamos le subimos la versi\u00f3n en la etiqueta: $ docker build -t username/friendlyhello -t username/friendlyhello:0.2.0 . De esta manera nuestra imagen aparecer\u00e1 con tres etiquetas: latest y 0.2.0 que ser\u00e1n la misma en realidad, y 0.1.0 . Ahora ya podemos enviar nuestra imagen: $ docker push username/friendlyhello Ejercicios: \u00b6 Cambia el docker-compose.yaml para usar tu imagen en vez de hacer build . Cambia el docker-compose.yaml para usar la imagen de alg\u00fan compa\u00f1ero.","title":"Crear im\u00e1genes propias"},{"location":"dockerfile/#crear-imagenes-propias","text":"Ya hemos visto como usar im\u00e1genes de terceros para crear aplicaciones y servicios. Pero, \u00bfsi no hay ninguna imagen que tenga lo que queremos? \u00bfO si queremos hacer una imagen de nuestra aplicaci\u00f3n para distribuirla? Docker permite crear imagenes propias. Aunque podr\u00edamos hacerla partiendo de cero, es un esfuerzo que no tiene sentido. Existe ya im\u00e1genes base para crear las nuestras y es mucho m\u00e1s f\u00e1cil crear una imagen bas\u00e1ndose en otra que hacerlo todo nosotros. Podemos partir de una imagen base que parte de un lenguaje de programaci\u00f3n ( python , php ) o de alguna distribuci\u00f3n ( ubuntu , debian ).","title":"Crear im\u00e1genes propias"},{"location":"dockerfile/#mi-primer-dockerfile","text":"Los Dockerfile son los archivos que contienen las instrucciones que crean las imagenes. Deben estar guardados dentro de un build context , es decir, un directorio. Este directorio es el que contiene todos los archivos necesarios para construir nuestra imagen, de ah\u00ed lo de build context . Creamos nuestro build context mkdir -p ~/Sites/hello-world cd ~/Sites/hello-world echo \"hello\" > hello Dentro de este directorio crearemos un archivo llamado Dockerfile con este contenido: FROM busybox COPY /hello / RUN cat /hello Directiva Explicaci\u00f3n FROM Indica la imagen base sobre la que se basa esta imagen COPY Copia un archivo del build context y lo guarda en la imagen RUN Ejecuta el comando indicado durante el proceso de creaci\u00f3n de imagen. Ahora para crear nuestra imagen usaremos docker build . docker build -t helloapp:v1 . El par\u00e1metro -t nos permite etiquetar la imagen con un nombre y una versi\u00f3n. El . indica que el build context es el directorio actual. El resultado de ejecutar lo anterior ser\u00eda: $ docker build -t helloapp:v1 . Sending build context to Docker daemon 3.072kB Step 1/3 : FROM busybox latest: Pulling from library/busybox 8c5a7da1afbc: Pull complete Digest: sha256:cb63aa0641a885f54de20f61d152187419e8f6b159ed11a251a09d115fdff9bd Status: Downloaded newer image for busybox:latest ---> e1ddd7948a1c Step 2/3 : COPY /hello / ---> 8a092965dbc9 Step 3/3 : RUN cat /hello ---> Running in 83b5498790ca hello Removing intermediate container 83b5498790ca ---> f738f117d4b6 Successfully built f738f117d4b6 Successfully tagged helloapp:v1 Y podremos ver que una nueva imagen est\u00e1 instalada en nuestro equipo: $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE helloapp v1 f738f117d4b6 40 seconds ago 1.16MB","title":"Mi primer Dockerfile"},{"location":"dockerfile/#creando-aplicaciones-en-contenedores","text":"Vamos a crear un aplicaci\u00f3n en python y la vamos a guardarla en un contenedor. Comenzamos creando un nuevo build context : mkdir -p ~/Sites/friendlyhello cd ~/Sites/friendlyhello El c\u00f3digo de la aplicaci\u00f3n es el siguiente, lo guardaremos en un archivo llamado app.py : from flask import Flask from redis import Redis , RedisError import os import socket # Connect to Redis redis = Redis ( host = \"redis\" , db = 0 , socket_connect_timeout = 2 , socket_timeout = 2 ) app = Flask ( __name__ ) @app . route ( \"/\" ) def hello (): try : visits = redis . incr ( \"counter\" ) except RedisError : visits = \"<i>cannot connect to Redis, counter disabled</i>\" html = \"<h3>Hello {name} !</h3>\" \\ \"<b>Hostname:</b> {hostname} <br/>\" \\ \"<b>Visits:</b> {visits} \" return html . format ( name = os . getenv ( \"NAME\" , \"world\" ), hostname = socket . gethostname (), visits = visits ) if __name__ == \"__main__\" : app . run ( host = '0.0.0.0' , port = 80 ) Nuestra aplicaci\u00f3n tiene una serie de dependencias (librer\u00edas de terceros) que guardaremos en el archivo requirements.txt : Flask Redis Y por \u00faltimo definimos nuestro Dockerfile : # Partimos de una base oficial de python FROM python:2.7-slim # El directorio de trabajo es desde donde se ejecuta el contenedor al iniciarse WORKDIR /app # Copiamos todos los archivos del build context al directorio /app del contenedor COPY . /app # Ejecutamos pip para instalar las dependencias en el contenedor RUN pip install --trusted-host pypi.python.org -r requirements.txt # Indicamos que este contenedor se comunica por el puerto 80/tcp EXPOSE 80 # Declaramos una variable de entorno ENV NAME World # Ejecuta nuestra aplicaci\u00f3n cuando se inicia el contenedor CMD [\"python\", \"app.py\"] Para conocer todas las directivas visita la documentaci\u00f3n oficial de Dockerfile . En total debemos tener 3 archivos: $ ls app.py Dockerfile requirements.txt Ahora construimos la imagen de nuestra aplicaci\u00f3n: docker build -t friendlyhello . Y comprobamos que est\u00e1 creada: $ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE friendlyhello latest 88a822b3107c 56 seconds ago 132MB","title":"Creando aplicaciones en contenedores"},{"location":"dockerfile/#probar-nuestro-contenedor","text":"Vamos a arrancar nuestro contenedor y probar la aplicaci\u00f3n: docker run --rm -p 4000:80 friendlyhello Tip Normalmente los contenedores son de usar y tirar, sobre todo cuando hacemos pruebas. El par\u00e1metro --rm borra autom\u00e1ticamente un contenedor cuando se para. Recordemos que los datos vol\u00e1tiles siempre se deben guardar en vol\u00famenes. Lo que arranca la aplicaci\u00f3n Flask: $ docker run --rm -p 4000:80 friendlyhello * Serving Flask app \"app\" (lazy loading) * Environment: production WARNING: Do not use the development server in a production environment. Use a production WSGI server instead. * Debug mode: off * Running on http://0.0.0.0:80/ (Press CTRL+C to quit) Comprobamos en el puerto 4000 si efectivamente est\u00e1 iniciada o no: http://localhost:4000 . Obtendremos un mensaje como este: Hello World! Hostname: 0367b056e66e Visits: cannot connect to Redis, counter disabled Ya tenemos una imagen lista para ser usada. Pulsamos Control+C para interrumpir y borrar nuestro contenedor.","title":"Probar nuestro contenedor"},{"location":"dockerfile/#creando-la-aplicacion","text":"En este caso nuestro contenedor no funciona por s\u00ed mismo. Es muy habitual que dependamos de servicios para poder iniciar la aplicaci\u00f3n, habitualmente bases de datos. En este caso necesitamos una base de datos Redis que no tenemos. Como vimos en el apartado anterior, vamos a aprovechar las caracter\u00edsticas de Compose para levantar nuestra aplicaci\u00f3n. Vamos a crear el siguiente archivo docker-compose.yaml : version : \"3\" services : web : build : . ports : - \"4000:80\" redis : image : redis ports : - \"6379:6379\" volumes : - \"./data:/data\" command : redis-server --appendonly yes La principal diferencia con respecto al cap\u00edtulo anterior, es que en un servicio podemos indicar una imagen (par\u00e1metro imagen ) o un build context (par\u00e1metro build ). Esta es una manera de integrar las dos herramientas que nos proporciona Docker : la creaci\u00f3n de im\u00e1genes y la composici\u00f3n de aplicaciones con servicios.","title":"Creando la aplicaci\u00f3n"},{"location":"dockerfile/#balanceo-de-carga","text":"Vamos a modificar nuestro docker-compose.yaml : version: \"3\" services: web: build: . redis: image: redis volumes: - \"./data:/data\" command: redis-server --appendonly yes lb: image: dockercloud/haproxy ports: - 4000:80 links: - web volumes: - /var/run/docker.sock:/var/run/docker.sock En este caso, el servicio web no va a tener acceso al exterior (hemos eliminado el par\u00e1metro ports ). En su lugar hemos a\u00f1adido un balanceador de carga (el servicio lb ). Vamos a arrancar esta nueva aplicaci\u00f3n, pero esta vez a\u00f1adiendo varios servicios web: docker-composer up -d --scale web=5 Esperamos a que terminen de iniciar los servicios: $ docker-compose up -d --scale web=5 Creating network \"friendlyhello_default\" with the default driver Creating friendlyhello_redis_1 ... done Creating friendlyhello_web_1 ... done Creating friendlyhello_web_2 ... done Creating friendlyhello_web_3 ... done Creating friendlyhello_web_4 ... done Creating friendlyhello_web_5 ... done Creating friendlyhello_lb_1 ... done Podemos comprobar como del servicio web nos ha iniciado 5 instancias, cada uno con su sufijo num\u00e9rico correspondiente. Si usamos docker ps para ver los contenedores disponibles tendremos: $ docker ps CONTAINER ID IMAGE [...] PORTS NAMES 77acae1d0567 dockercloud/haproxy [...] 443/tcp, 1936/tcp, 0.0.0.0:4000->80/tcp friendlyhello_lb_1 5f12fb8b80c8 friendlyhello_web [...] 80/tcp friendlyhello_web_5 fb0024591665 friendlyhello_web [...] 80/tcp friendlyhello_web_2 a20d20bdd129 friendlyhello_web [...] 80/tcp friendlyhello_web_4 53d7db212df8 friendlyhello_web [...] 80/tcp friendlyhello_web_3 41218dbbb882 friendlyhello_web [...] 80/tcp friendlyhello_web_1 06f5bf6ed070 redis [...] 6379/tcp friendlyhello_redis_1 Vamos a fijarnos en el CONTAINER ID y vamos a volver a abrir nuestra aplicaci\u00f3n: http://localhost:4000 . Si en esta ocasi\u00f3n vamos recargando la p\u00e1gina, veremos como cambian los hostnames , que a su vez coinciden con los identificadores de los contenedores anteriores. Info Esta no es la manera adecuada de hacer balanceo de carga, puesto que todos los contenedores est\u00e1n en la misma m\u00e1quina, lo cual no tiene sentido. Solo es una demostraci\u00f3n. Para hacer balanceo de carga real necesitar\u00edamos tener o emular un clustes de m\u00e1quinas y crear un enjambre ( swarm ).","title":"Balanceo de carga"},{"location":"dockerfile/#compartir-imagenes","text":"Si tenemos una imagen que queramos compartir, necesitamos usar un registro. Existe incluso una imagen que nos permite crear uno propio, pero vamos a usar el repositorio p\u00fablico de Docker . Los pasos son: Crear una cuenta de usuario en el repositorio oficial de Docker . Pulsar sobre el bot\u00f3n \" Create Repository + \". En el formulario hay que rellenar solo un dato obligatoriamente: el nombre. Usaremos el de la imagen: friendlyhello . Nuestro nombre de usuario es el namespace y es obligatorio que tenga uno. Si estuvieramos en alguna organizaci\u00f3n podr\u00edamos elegir entre varios. El resto de campos lo dejamos como est\u00e1 por el momento. La cuenta gratuita solo deja tener un repositorio privado, asi que no lo malgastaremos aqu\u00ed. Ahora tenemos que conectar nuestro cliente de Docker con nuestra cuenta en el Hub . Usamos el comando docker login . $ docker login Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one. Username: username Password: ******** WARNING! Your password will be stored unencrypted in /home/sergio/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Danger Las claves se guardan sin cifrar. Hay que configurar un almacen de claves o recordar hacer docker logout para borrarla. Visita la web de referencia para saber como crear un almacen . Para que las im\u00e1genes se puedan guardar, tenemos que etiquetarla con el mismo nombre que tengamos en nuestro repositorio m\u00e1s el namespace . Si nuestra cuenta es ' username ' y el repositorio es ' friendlyhello ', debemos crear la imagen con la etiqueta ' username/friendlyhello '. $ docker build -t username/friendlyhello . Tip Por defecto ya hemos dicho que la etiqueta si no se indica es latest . Podemos indicar m\u00e1s de una etiqueta para indicar versiones: $ docker build -t username/friendlyhello -t username/friendlyhello:0.1.0 . En la pr\u00f3xima que hagamos le subimos la versi\u00f3n en la etiqueta: $ docker build -t username/friendlyhello -t username/friendlyhello:0.2.0 . De esta manera nuestra imagen aparecer\u00e1 con tres etiquetas: latest y 0.2.0 que ser\u00e1n la misma en realidad, y 0.1.0 . Ahora ya podemos enviar nuestra imagen: $ docker push username/friendlyhello","title":"Compartir im\u00e1genes"},{"location":"dockerfile/#ejercicios","text":"Cambia el docker-compose.yaml para usar tu imagen en vez de hacer build . Cambia el docker-compose.yaml para usar la imagen de alg\u00fan compa\u00f1ero.","title":"Ejercicios:"},{"location":"images/","text":"Im\u00e1genes \u00b6 Las im\u00e1genes son la base de Docker. Nuestros contenedores se iniciar\u00e1n a partir de ellas. Como se indic\u00f3 en la introducci\u00f3n, es una plantilla de solo lectura, que se crea incorporando los requisitos necesarios para cumplir el objetivo para el cual fue creada. Por ejemplo, si estamos creando un proyecto con PHP, incorporar\u00e1 el int\u00e9rprete del lenguaje de PHP. Si es una p\u00e1gina web, incorporar\u00e1 el servidor web ( apache , nginx , etc.). Buscar im\u00e1genes \u00b6 Crear una imagen desde cero supone un esfuerzo demasiado grande, as\u00ed que lo normal es partir o usar una ya creada. Para ellos buscaremos en los registros, el lugar donde se almacenan. Hay un registro oficial ( https://hub.docker.com ), pero nada impide a otras organizaciones, o a nosotros mismo, tener un registro propio. Estos registros pueden ser privados o p\u00fablicos. Imaginemos que queremos crear una web con WordPress . Si buscamos en el registro encontraremos una imagen llamada wordpress , con la etiqueta oficial. La recomendaci\u00f3n es que siempre busquemos im\u00e1genes oficiales, est\u00e1n mantenidas y bien documentadas. En la p\u00e1gina encontraremos las diferentes opciones que tiene esta imagen para configurarla, aunque las veremos con m\u00e1s detalle m\u00e1s adelante. Por ahora iniciemos la imagen como se indica: Example Iniciar una imagen de WordPress : docker run -p 8080:80 wordpress Y comprobaremos como se inicia el contenedor: $ docker run -p 8080 :80 wordpress Unable to find image 'wordpress:latest' locally latest: Pulling from library/wordpress 802b00ed6f79: Pull complete 59f5a5a895f8: Pull complete 6898b2dbcfeb: Pull complete 8e0903aaa47e: Pull complete 2961af1e196a: Pull complete 71f7016f79a0: Pull complete 5e1a48e5719c: Pull complete 7ae5291984f3: Pull complete 725b65166f31: Pull complete e90b121f9520: Pull complete b5a272809bbd: Pull complete f045f3ae0e2b: Pull complete 7f51c9ea2d8e: Pull complete 5aa9d0ed164a: Pull complete 8eea44e2bfc7: Pull complete 48918885026e: Pull complete 8ac3e8ada01a: Pull complete d3da911b920f: Pull complete 94c7e0af5b20: Pull complete e1f39ac90dec: Pull complete Digest: sha256:7121cdf8e9f01816653a3b2d2f4fc7bfe1dab956f00db5c7e7689e5f1454029a Status: Downloaded newer image for wordpress:latest WordPress not found in /var/www/html - copying now... Complete! WordPress has been successfully copied to /var/www/html AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 10.17.0.1. Set the 'ServerName' directive globally to suppress this message AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 10.17.0.1. Set the 'ServerName' directive globally to suppress this message [DDD mmm dd hh:mm:ss.iiiiii yyyy] [mpm_prefork:notice] [pid 1] AH00163: Apache/2.4.25 (Debian) PHP/7.2.10 configured -- resuming normal operations [DDD mmm dd hh:mm:ss.iiiiii yyyy] [core:notice] [pid 1] AH00094: Command line: 'apache2 -D FOREGROUND' Vemos en la l\u00ednea nueva un nuevo par\u00e1metro: -p 8080:80 . Por defecto, un contenedor est\u00e1 totalmente aislado. Pero si estamos montando un blog con WordPress vamos a necesitar acceder a \u00e9l desde el navegador. Con el par\u00e1metro -p , versi\u00f3n corta de --publish , podemos indicar que estamos enlazando un puerto de la m\u00e1quina anfitri\u00f3n con el contenedor. En este caso estamos enlazando el puerto 8080 de la m\u00e1quina anfitri\u00f3n con el 80 del contenedor. Info No vamos a explicar todas las opciones posibles, el tutorial ser\u00eda demasiado largo. Puedes consultar la p\u00e1gina del manual con man docker-run o llamando a la ayuda desde el cliente con docker run --help . En este caso, el formato de publish es: -p, --publish ip:[hostPort]:containerPort | [hostPort:]containerPort Publish a container's port, or range of ports, to the host. Both hostPort and containerPort can be specified as a range. When specifying ranges for both, the number of ports in ranges should be equal. Examples: -p 1234-1236:1222-1224, -p 127.0.0.1:$HOSTPORT:$CONTAINERPORT. Use docker port(1) to see the actual mapping, e.g. docker port CONTAINER $CONTAINERPORT. Vamos a abrir la siguiente p\u00e1gina web en nuestro navegador: http://localhost:8080 La cual nos mostrar\u00e1 el asistente de instalaci\u00f3n de WordPress , el cual no vamos a instalar porque necesitamos una base de datos que a\u00fan no tenemos. En su lugar vamos a la consola e interrumpimos la ejecuci\u00f3n del contenedor con Control+C : ^C[DDD mmm dd hh:mm:ss.iiiiii yyyy] [mpm_prefork:notice] [pid 1] AH00169: caught SIGTERM, shutting down Gesti\u00f3n de im\u00e1genes \u00b6 Descarga \u00b6 Las imagenes que nos descargamos se identifican, adem\u00e1s de por el nombre, por una versi\u00f3n. De esa manera podemos tener distintas versiones de una misma imagen. En la p\u00e1gina del registro de WordPress veremos una pesta\u00f1a con el nombre Tags , con las versiones disponibles. Para usar una en concreto se usa dos puntos seguido del nombre de la versi\u00f3n. Si no se indica nada, como hasta ahora, por defecto se descarga la etiquetada como latest . Podemos descargar im\u00e1genes con la orden docker pull : $ docker pull wordpress:latest latest: Pulling from library/wordpress Digest: sha256:7121cdf8e9f01816653a3b2d2f4fc7bfe1dab956f00db5c7e7689e5f1454029a Status: Image is up to date for wordpress:latest $ docker pull wordpress:php7.1 php7.1: Pulling from library/wordpress 802b00ed6f79: Already exists 59f5a5a895f8: Already exists 6898b2dbcfeb: Already exists 8e0903aaa47e: Already exists 2961af1e196a: Already exists 71f7016f79a0: Already exists 5e1a48e5719c: Already exists 7ae5291984f3: Already exists 725b65166f31: Already exists a2d738459b49: Pull complete 24830994a3eb: Pull complete b3807dc98c17: Pull complete 59365c2968b5: Pull complete 36bea53859bb: Pull complete a777908b01b4: Pull complete bd3efa4fff20: Pull complete 662f2add84f7: Pull complete 4340a5e4d9f8: Pull complete 2dbeaf456768: Pull complete Digest: sha256:2cc529d3d4ac538f8565d18a893bd1308d6f5522422f4696d87267695f69702c Status: Downloaded newer image for wordpress:php7.1 En el primer caso no hay descarga porque esa versi\u00f3n ya estaba descargada, en la segunda nos descargamos la versi\u00f3n de la imagen que usa php7.1 en vez de php7.2 Listado \u00b6 Para ver el listado de images disponibles usamos docker images : $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE wordpress latest ca0fefec932b 7 days ago 409MB wordpress php7.1 37664bd9863e 7 days ago 400MB hello-world latest 4ab4c602aa5e 2 weeks ago 1.84kB Borrado \u00b6 Si queremos dejar de usar alguna imagen usaremos docker rmi : $ docker rmi wordpress:php7.1 Untagged: wordpress:php7.1 Untagged: wordpress@sha256:2cc529d3d4ac538f8565d18a893bd1308d6f5522422f4696d87267695f69702c Deleted: sha256:37664bd9863efe67a83cb2ff293f1816a9b5f918668ae19ca36b2af3d3b9f62d Deleted: sha256:77c97f008777c89455c8e5f248a626b192b62cf07ed1993c9acdfab73be210ee Deleted: sha256:14f58345b0bb2efaede03f9424412dce141ea275343305a79952c9c8bda3d1ba Deleted: sha256:5902e2becea5be6d672e8a6a84cc66a2f3b8e1b209302a9995de2b9afac8535f Deleted: sha256:a5b592bce0a767eed15cce29e5e4a941341a0b8de1633ab8836079c03af31b9e Deleted: sha256:6cc2318a4f6975aa87358d9f2852d8b91b335515a1d42ef141af368ee0b6fc05 Deleted: sha256:c3c8b98ead26315e76cd9625fd59f67cab81afa7810b84a229f4e612097a3db4 Deleted: sha256:a641d6d5a4f43b035946f9a82c9f126189e8502567bb17c41d25e922a5b314a3 Deleted: sha256:a7338078acb6f6e8b1a152dabd6e7e47b3e530e1f2e2169b8b69127c9578f8fe Deleted: sha256:8f416a21cdea7d5b42d6b799ab4ade2dffe1f6a3b9d83dd02be47a82699922de Deleted: sha256:53862f425fbc706f70bd1238a0e929bf6d648547481acfad4910c4c1bde39b95 Warning Si una imagen est\u00e1 en uso por alg\u00fan contenedor, no nos dejar\u00e1 eliminarla. $ docker rmi hello-world:latest Error response from daemon: conflict: unable to remove repository reference \"hello-world:latest\" (must force) - container 5ae8bbb8768d is using its referenced image 4ab4c602aa5e","title":"Im\u00e1genes"},{"location":"images/#imagenes","text":"Las im\u00e1genes son la base de Docker. Nuestros contenedores se iniciar\u00e1n a partir de ellas. Como se indic\u00f3 en la introducci\u00f3n, es una plantilla de solo lectura, que se crea incorporando los requisitos necesarios para cumplir el objetivo para el cual fue creada. Por ejemplo, si estamos creando un proyecto con PHP, incorporar\u00e1 el int\u00e9rprete del lenguaje de PHP. Si es una p\u00e1gina web, incorporar\u00e1 el servidor web ( apache , nginx , etc.).","title":"Im\u00e1genes"},{"location":"images/#buscar-imagenes","text":"Crear una imagen desde cero supone un esfuerzo demasiado grande, as\u00ed que lo normal es partir o usar una ya creada. Para ellos buscaremos en los registros, el lugar donde se almacenan. Hay un registro oficial ( https://hub.docker.com ), pero nada impide a otras organizaciones, o a nosotros mismo, tener un registro propio. Estos registros pueden ser privados o p\u00fablicos. Imaginemos que queremos crear una web con WordPress . Si buscamos en el registro encontraremos una imagen llamada wordpress , con la etiqueta oficial. La recomendaci\u00f3n es que siempre busquemos im\u00e1genes oficiales, est\u00e1n mantenidas y bien documentadas. En la p\u00e1gina encontraremos las diferentes opciones que tiene esta imagen para configurarla, aunque las veremos con m\u00e1s detalle m\u00e1s adelante. Por ahora iniciemos la imagen como se indica: Example Iniciar una imagen de WordPress : docker run -p 8080:80 wordpress Y comprobaremos como se inicia el contenedor: $ docker run -p 8080 :80 wordpress Unable to find image 'wordpress:latest' locally latest: Pulling from library/wordpress 802b00ed6f79: Pull complete 59f5a5a895f8: Pull complete 6898b2dbcfeb: Pull complete 8e0903aaa47e: Pull complete 2961af1e196a: Pull complete 71f7016f79a0: Pull complete 5e1a48e5719c: Pull complete 7ae5291984f3: Pull complete 725b65166f31: Pull complete e90b121f9520: Pull complete b5a272809bbd: Pull complete f045f3ae0e2b: Pull complete 7f51c9ea2d8e: Pull complete 5aa9d0ed164a: Pull complete 8eea44e2bfc7: Pull complete 48918885026e: Pull complete 8ac3e8ada01a: Pull complete d3da911b920f: Pull complete 94c7e0af5b20: Pull complete e1f39ac90dec: Pull complete Digest: sha256:7121cdf8e9f01816653a3b2d2f4fc7bfe1dab956f00db5c7e7689e5f1454029a Status: Downloaded newer image for wordpress:latest WordPress not found in /var/www/html - copying now... Complete! WordPress has been successfully copied to /var/www/html AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 10.17.0.1. Set the 'ServerName' directive globally to suppress this message AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 10.17.0.1. Set the 'ServerName' directive globally to suppress this message [DDD mmm dd hh:mm:ss.iiiiii yyyy] [mpm_prefork:notice] [pid 1] AH00163: Apache/2.4.25 (Debian) PHP/7.2.10 configured -- resuming normal operations [DDD mmm dd hh:mm:ss.iiiiii yyyy] [core:notice] [pid 1] AH00094: Command line: 'apache2 -D FOREGROUND' Vemos en la l\u00ednea nueva un nuevo par\u00e1metro: -p 8080:80 . Por defecto, un contenedor est\u00e1 totalmente aislado. Pero si estamos montando un blog con WordPress vamos a necesitar acceder a \u00e9l desde el navegador. Con el par\u00e1metro -p , versi\u00f3n corta de --publish , podemos indicar que estamos enlazando un puerto de la m\u00e1quina anfitri\u00f3n con el contenedor. En este caso estamos enlazando el puerto 8080 de la m\u00e1quina anfitri\u00f3n con el 80 del contenedor. Info No vamos a explicar todas las opciones posibles, el tutorial ser\u00eda demasiado largo. Puedes consultar la p\u00e1gina del manual con man docker-run o llamando a la ayuda desde el cliente con docker run --help . En este caso, el formato de publish es: -p, --publish ip:[hostPort]:containerPort | [hostPort:]containerPort Publish a container's port, or range of ports, to the host. Both hostPort and containerPort can be specified as a range. When specifying ranges for both, the number of ports in ranges should be equal. Examples: -p 1234-1236:1222-1224, -p 127.0.0.1:$HOSTPORT:$CONTAINERPORT. Use docker port(1) to see the actual mapping, e.g. docker port CONTAINER $CONTAINERPORT. Vamos a abrir la siguiente p\u00e1gina web en nuestro navegador: http://localhost:8080 La cual nos mostrar\u00e1 el asistente de instalaci\u00f3n de WordPress , el cual no vamos a instalar porque necesitamos una base de datos que a\u00fan no tenemos. En su lugar vamos a la consola e interrumpimos la ejecuci\u00f3n del contenedor con Control+C : ^C[DDD mmm dd hh:mm:ss.iiiiii yyyy] [mpm_prefork:notice] [pid 1] AH00169: caught SIGTERM, shutting down","title":"Buscar im\u00e1genes"},{"location":"images/#gestion-de-imagenes","text":"","title":"Gesti\u00f3n de im\u00e1genes"},{"location":"images/#descarga","text":"Las imagenes que nos descargamos se identifican, adem\u00e1s de por el nombre, por una versi\u00f3n. De esa manera podemos tener distintas versiones de una misma imagen. En la p\u00e1gina del registro de WordPress veremos una pesta\u00f1a con el nombre Tags , con las versiones disponibles. Para usar una en concreto se usa dos puntos seguido del nombre de la versi\u00f3n. Si no se indica nada, como hasta ahora, por defecto se descarga la etiquetada como latest . Podemos descargar im\u00e1genes con la orden docker pull : $ docker pull wordpress:latest latest: Pulling from library/wordpress Digest: sha256:7121cdf8e9f01816653a3b2d2f4fc7bfe1dab956f00db5c7e7689e5f1454029a Status: Image is up to date for wordpress:latest $ docker pull wordpress:php7.1 php7.1: Pulling from library/wordpress 802b00ed6f79: Already exists 59f5a5a895f8: Already exists 6898b2dbcfeb: Already exists 8e0903aaa47e: Already exists 2961af1e196a: Already exists 71f7016f79a0: Already exists 5e1a48e5719c: Already exists 7ae5291984f3: Already exists 725b65166f31: Already exists a2d738459b49: Pull complete 24830994a3eb: Pull complete b3807dc98c17: Pull complete 59365c2968b5: Pull complete 36bea53859bb: Pull complete a777908b01b4: Pull complete bd3efa4fff20: Pull complete 662f2add84f7: Pull complete 4340a5e4d9f8: Pull complete 2dbeaf456768: Pull complete Digest: sha256:2cc529d3d4ac538f8565d18a893bd1308d6f5522422f4696d87267695f69702c Status: Downloaded newer image for wordpress:php7.1 En el primer caso no hay descarga porque esa versi\u00f3n ya estaba descargada, en la segunda nos descargamos la versi\u00f3n de la imagen que usa php7.1 en vez de php7.2","title":"Descarga"},{"location":"images/#listado","text":"Para ver el listado de images disponibles usamos docker images : $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE wordpress latest ca0fefec932b 7 days ago 409MB wordpress php7.1 37664bd9863e 7 days ago 400MB hello-world latest 4ab4c602aa5e 2 weeks ago 1.84kB","title":"Listado"},{"location":"images/#borrado","text":"Si queremos dejar de usar alguna imagen usaremos docker rmi : $ docker rmi wordpress:php7.1 Untagged: wordpress:php7.1 Untagged: wordpress@sha256:2cc529d3d4ac538f8565d18a893bd1308d6f5522422f4696d87267695f69702c Deleted: sha256:37664bd9863efe67a83cb2ff293f1816a9b5f918668ae19ca36b2af3d3b9f62d Deleted: sha256:77c97f008777c89455c8e5f248a626b192b62cf07ed1993c9acdfab73be210ee Deleted: sha256:14f58345b0bb2efaede03f9424412dce141ea275343305a79952c9c8bda3d1ba Deleted: sha256:5902e2becea5be6d672e8a6a84cc66a2f3b8e1b209302a9995de2b9afac8535f Deleted: sha256:a5b592bce0a767eed15cce29e5e4a941341a0b8de1633ab8836079c03af31b9e Deleted: sha256:6cc2318a4f6975aa87358d9f2852d8b91b335515a1d42ef141af368ee0b6fc05 Deleted: sha256:c3c8b98ead26315e76cd9625fd59f67cab81afa7810b84a229f4e612097a3db4 Deleted: sha256:a641d6d5a4f43b035946f9a82c9f126189e8502567bb17c41d25e922a5b314a3 Deleted: sha256:a7338078acb6f6e8b1a152dabd6e7e47b3e530e1f2e2169b8b69127c9578f8fe Deleted: sha256:8f416a21cdea7d5b42d6b799ab4ade2dffe1f6a3b9d83dd02be47a82699922de Deleted: sha256:53862f425fbc706f70bd1238a0e929bf6d648547481acfad4910c4c1bde39b95 Warning Si una imagen est\u00e1 en uso por alg\u00fan contenedor, no nos dejar\u00e1 eliminarla. $ docker rmi hello-world:latest Error response from daemon: conflict: unable to remove repository reference \"hello-world:latest\" (must force) - container 5ae8bbb8768d is using its referenced image 4ab4c602aa5e","title":"Borrado"},{"location":"installation/","text":"Instalaci\u00f3n \u00b6 Existe dos versiones de Docker, una libre y otra que no lo es. Nos ocuparemos exclusivamente de la primera: Docker CE (Community Edition) . Disponibilidad \u00b6 Docker CE est\u00e1 disponible para los siguientes sistemas GNU/Linux: CentOS, Debian, Fedora y Ubuntu. No todas est\u00e1n en m\u00faltiples arquitecturas, pero s\u00ed todas soportan x86_64/amd64 . Si tienes otra arquitectura u otro sistema es mejor que uses una m\u00e1quina virtual para arrancar una distribuci\u00f3n compatible. Para m\u00e1s informaci\u00f3n sobre sistemas privativos soportados, leer la secci\u00f3n de plataformas soportadas de la documentaci\u00f3n oficial. Instalaci\u00f3n \u00b6 Debido a que, dependiendo de la distribuci\u00f3n, la forma de instalarlo difiere, es mejor consultar la documentaci\u00f3n oficial para saber como instalar Docker en tu m\u00e1quina. Ubuntu: https://docs.docker.com/install/linux/docker-ce/ubuntu/ Debian: https://docs.docker.com/install/linux/docker-ce/debian/ CentOS: https://docs.docker.com/install/linux/docker-ce/centos/ Fedora: https://docs.docker.com/install/linux/docker-ce/fedora/ Si quieres instalar y probar Linux por primera vez, te recomendamos que uses una versi\u00f3n LTS de Ubuntu , por ser f\u00e1cil de instalar y tener un ciclo de mantenimiento de seguridad ampliado. Obviamente necesitas tener conexi\u00f3n a Internet para instalar y probar Docker. Para saber si tienes Docker bien instalado, los tutoriales oficiales siempre te indican inicies un contenedor de ejemplo. Esto es lo que sucede: Example Los c\u00f3digos de ejemplo ir\u00e1n acompa\u00f1ados de una caja como esta para poder copiar y pegar los comandos. sudo docker run hello-world El resultado es el siguiente: $ sudo docker run hello-world Unable to find image 'hello-world:latest' locally latest: Pulling from library/hello-world d1725b59e92d: Pull complete Digest: sha256:0add3ace90ecb4adbf7777e9aacf18357296e799f81cabc9fde470971e499788 Status: Downloaded newer image for hello-world:latest Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1 . The Docker client contacted the Docker daemon. 2 . The Docker daemon pulled the \"hello-world\" image from the Docker Hub. ( amd64 ) 3 . The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4 . The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/ En la l\u00ednea 1 estamos ejecutando el cliente de Docker, y estamos indicando que queremos ejecutar un contenedor a partir de la imagen hello-world del registro p\u00fablico de Docker. Si es la primera vez que hemos ejecutado esa imagen, nos aparecer\u00e1 la l\u00ednea 2, que indica que la imagen no puede ser encontrada y va a proceder a buscarla, por defecto, en el registro p\u00fablico. Si tenemos conexi\u00f3n a Internet se descargar\u00e1 la imagen (l\u00ednea 6) y autom\u00e1ticamente crear\u00e1 un contenedor. Tanto si se ha descargado la imagen o ya estaba descargada, el contenedor se ejecutar\u00e1, obteniendo el texto de bienvenida que se ve en el cuadro anterior. Configuraci\u00f3n del usuario \u00b6 Si estamos usando Docker en nuestro ordenador personal, podemos configurar nuestro usuario para usar el cliente sin tener que poner sudo delante. Para ello ejecuta lo siguiente: Example A\u00f1ade tu usuario al grupo de docker. sudo usermod -aG docker $USER Para que los nuevos permisos surtan efecto, debes cerrar y volver a abrir la sesi\u00f3n. Para problemas relacionados con los permisos visitad la p\u00e1gina del manual oficial . Requisitos del curso \u00b6 Im\u00e1genes \u00b6 Es necesario traer ya instaladas ciertas im\u00e1genes de contenedores. Ejecuta los siguientes comandos en tu equipo (si te da error de permisos aseg\u00farate que has hecho el apartado anterior y abierto y cerrado la sesi\u00f3n). Example Instalar WordPress : docker pull wordpress:latest Example Instalar MariaDB : docker pull mariadb:latest Herramientas \u00b6 Tambi\u00e9n es necesario traer una herramienta llamada Docker Compose . Puedes instalarla con las instrucciones que hay en la p\u00e1gina de Instalaci\u00f3n de Docker Compose . Sin embargo, si usas Ubuntu o Debian puedes instalarlo de forma m\u00e1s f\u00e1cil con apt : Example Instalaci\u00f3n de Docker Compose : sudo apt install docker-compose","title":"Instalaci\u00f3n"},{"location":"installation/#instalacion","text":"Existe dos versiones de Docker, una libre y otra que no lo es. Nos ocuparemos exclusivamente de la primera: Docker CE (Community Edition) .","title":"Instalaci\u00f3n"},{"location":"installation/#disponibilidad","text":"Docker CE est\u00e1 disponible para los siguientes sistemas GNU/Linux: CentOS, Debian, Fedora y Ubuntu. No todas est\u00e1n en m\u00faltiples arquitecturas, pero s\u00ed todas soportan x86_64/amd64 . Si tienes otra arquitectura u otro sistema es mejor que uses una m\u00e1quina virtual para arrancar una distribuci\u00f3n compatible. Para m\u00e1s informaci\u00f3n sobre sistemas privativos soportados, leer la secci\u00f3n de plataformas soportadas de la documentaci\u00f3n oficial.","title":"Disponibilidad"},{"location":"installation/#instalacion_1","text":"Debido a que, dependiendo de la distribuci\u00f3n, la forma de instalarlo difiere, es mejor consultar la documentaci\u00f3n oficial para saber como instalar Docker en tu m\u00e1quina. Ubuntu: https://docs.docker.com/install/linux/docker-ce/ubuntu/ Debian: https://docs.docker.com/install/linux/docker-ce/debian/ CentOS: https://docs.docker.com/install/linux/docker-ce/centos/ Fedora: https://docs.docker.com/install/linux/docker-ce/fedora/ Si quieres instalar y probar Linux por primera vez, te recomendamos que uses una versi\u00f3n LTS de Ubuntu , por ser f\u00e1cil de instalar y tener un ciclo de mantenimiento de seguridad ampliado. Obviamente necesitas tener conexi\u00f3n a Internet para instalar y probar Docker. Para saber si tienes Docker bien instalado, los tutoriales oficiales siempre te indican inicies un contenedor de ejemplo. Esto es lo que sucede: Example Los c\u00f3digos de ejemplo ir\u00e1n acompa\u00f1ados de una caja como esta para poder copiar y pegar los comandos. sudo docker run hello-world El resultado es el siguiente: $ sudo docker run hello-world Unable to find image 'hello-world:latest' locally latest: Pulling from library/hello-world d1725b59e92d: Pull complete Digest: sha256:0add3ace90ecb4adbf7777e9aacf18357296e799f81cabc9fde470971e499788 Status: Downloaded newer image for hello-world:latest Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1 . The Docker client contacted the Docker daemon. 2 . The Docker daemon pulled the \"hello-world\" image from the Docker Hub. ( amd64 ) 3 . The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4 . The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/ En la l\u00ednea 1 estamos ejecutando el cliente de Docker, y estamos indicando que queremos ejecutar un contenedor a partir de la imagen hello-world del registro p\u00fablico de Docker. Si es la primera vez que hemos ejecutado esa imagen, nos aparecer\u00e1 la l\u00ednea 2, que indica que la imagen no puede ser encontrada y va a proceder a buscarla, por defecto, en el registro p\u00fablico. Si tenemos conexi\u00f3n a Internet se descargar\u00e1 la imagen (l\u00ednea 6) y autom\u00e1ticamente crear\u00e1 un contenedor. Tanto si se ha descargado la imagen o ya estaba descargada, el contenedor se ejecutar\u00e1, obteniendo el texto de bienvenida que se ve en el cuadro anterior.","title":"Instalaci\u00f3n"},{"location":"installation/#configuracion-del-usuario","text":"Si estamos usando Docker en nuestro ordenador personal, podemos configurar nuestro usuario para usar el cliente sin tener que poner sudo delante. Para ello ejecuta lo siguiente: Example A\u00f1ade tu usuario al grupo de docker. sudo usermod -aG docker $USER Para que los nuevos permisos surtan efecto, debes cerrar y volver a abrir la sesi\u00f3n. Para problemas relacionados con los permisos visitad la p\u00e1gina del manual oficial .","title":"Configuraci\u00f3n del usuario"},{"location":"installation/#requisitos-del-curso","text":"","title":"Requisitos del curso"},{"location":"installation/#imagenes","text":"Es necesario traer ya instaladas ciertas im\u00e1genes de contenedores. Ejecuta los siguientes comandos en tu equipo (si te da error de permisos aseg\u00farate que has hecho el apartado anterior y abierto y cerrado la sesi\u00f3n). Example Instalar WordPress : docker pull wordpress:latest Example Instalar MariaDB : docker pull mariadb:latest","title":"Im\u00e1genes"},{"location":"installation/#herramientas","text":"Tambi\u00e9n es necesario traer una herramienta llamada Docker Compose . Puedes instalarla con las instrucciones que hay en la p\u00e1gina de Instalaci\u00f3n de Docker Compose . Sin embargo, si usas Ubuntu o Debian puedes instalarlo de forma m\u00e1s f\u00e1cil con apt : Example Instalaci\u00f3n de Docker Compose : sudo apt install docker-compose","title":"Herramientas"},{"location":"introduction/","text":"Introducci\u00f3n \u00b6 Seg\u00fan la Wikipedia: \"Docker es un proyecto de c\u00f3digo abierto que automatiza el despliegue de aplicaciones dentro de contenedores de software, proporcionando una capa adicional de abstracci\u00f3n y automatizaci\u00f3n de virtualizaci\u00f3n de aplicaciones en m\u00faltiples sistemas operativos. Docker utiliza caracter\u00edsticas de aislamiento de recursos del kernel Linux, tales como cgroups y espacios de nombres (namespaces) para permitir que 'contenedores' independientes se ejecuten dentro de una sola instancia de Linux, evitando la sobrecarga de iniciar y mantener m\u00e1quinas virtuales.\" 1 . Esto es una descripci\u00f3n formal, pero para enterarte de qu\u00e9 es docker sigue leyendo: \u00bfA qui\u00e9n le puede interesar usar docker? \u00b6 Docker es \u00fatil a administradores de sistemas, pero tambi\u00e9n a desarrolladores. Uno de los problemas que se presentan durante el desarrollo y despliegue de aplicaciones es encontrarnos con sistemas heterog\u00e9neos, no ya entre los desarrolladores, tambi\u00e9n entre los sistemas de pruebas, pre-producci\u00f3n y producci\u00f3n. Es decir, que los desarrolladores y los sistemas donde se ejecuta la aplicaci\u00f3n tienen librer\u00edas y sistemas operativos diferentes. \u00bfY por qu\u00e9 es un problema? Pues porque la aplicaci\u00f3n puede funcionar bien en una distribuci\u00f3n de GNU/Linux pero no bien en otra, o ejecutarse bien con la versi\u00f3n de un lenguaje pero no con otra. Para asegurar la calidad de desarrollo tenemos que asegurar que todo el mundo usa las mismas versiones de todas las aplicaciones y librer\u00edas necesarios. Esto es m\u00e1s complicado de lo que parece, porque hay desarrolladores que prefieron una distribuci\u00f3n concreta, o incluso sistemas privativos. Incluso los sistemas de pruebas, pre-producci\u00f3n y producci\u00f3n suelen ser distintos. Los sistemas de producci\u00f3n suelen ser m\u00e1s nuevos y potentes y los antiguos se dejan para pruebas y pre-producci\u00f3n. Otro problema es que un mismo desarrollador o un mismo sistema de despliegue tenga que trabajar en m\u00e1s de un proyecto que requiera versiones distintas de librer\u00edas, complic\u00e1ndolo a\u00fan m\u00e1s. Docker viene a solucionar todos estos problemas, tanto para los desarrolladores como para los administradores de sistemas. Con Docker podemos crear entornos aislados con configuraciones que ser\u00e1n exactamente igual siempre. \u00bfDocker es virtualizaci\u00f3n? \u00b6 En GNU/Linux Docker no es virtualizado, no hay un hipervisor. Los procesos que corren dentro de un contenedor de docker se ejecutan con el mismo kernel que la m\u00e1quina anfitri\u00f3n. Linux lo que hace es aislar esos procesos del resto de procesos del sistema, ya sean los propios de la m\u00e1quina anfitri\u00f3n o procesos de otros contenedores. Adem\u00e1s, es capaz de controlar los recursos que se le asignan a esos contenedores (cpu, memoria, red, etc.). Internamente, el contenedor no sabe que lo es y a todos los efectos es una distribuci\u00f3n GNU/Linux independiente, pero sin la penalizaci\u00f3n de rendimiento que tienen los sistemas virtualizados. As\u00ed que, cuando ejecutamos un contenedor, estamos ejecutando un servicio dentro de una distribuci\u00f3n construida a partir de una \"receta\". Esa receta permite que el sistema que se ejecuta sea siempre el mismo, independientemente de si estamos usando Docker en Ubuntu, Fedora o, incluso, sistemas privativos compatibles con Docker. De esa manera podemos garantizar que estamos desarrollando o desplegando nuestra aplicaci\u00f3n, siempre con la misma versi\u00f3n de todas las dependencias. Obviamente, si ejecutamos contenedores GNU/Linux dentro de sistemas privativos, s\u00ed habr\u00e1 virtualizaci\u00f3n. Conceptos b\u00e1sicos \u00b6 Antes de comenzar a instalar y usar docker es importante tener una serie de conceptos claros 2 : Demonio de docker (docker daemon) Es el proceso principal de docker. Escucha peticiones a la API y maneja los objetos de docker: im\u00e1genes, contenedores, redes, vol\u00famenes. Tambi\u00e9n es capaz de comunicarse con otros demonios para controlar servicios docker. Cliente de docker (docker client) Es la principal herramienta que usan los administradores de sistema para interaccionar con el sistema Docker. Registro de docker (docker registry) Es el lugar donde se almacenan las im\u00e1genes de Docker y poder descargarlas para reutilizarlas. Docker Hub es el principal registro p\u00fablico de Docker y contiene ya un mont\u00f3n de im\u00e1genes listas para ser usadas de multitud de servicios (mysql, wordpress, etc). Objetos de docker \u00b6 Cuando usamos Docker, estamos creando y usando im\u00e1genes, contenedores, redes o vol\u00famenes, entre otros. A todo esto se le denominan objetos. Veamos los m\u00e1s importantes: Imagen (image) Plantilla de solo lectura que contiene las instrucciones para crear un contenedor Docker. Pueden estar basadas en otras imagenes, lo cual es habitual. Contenedor (container) Es una instancia ejecutable de una imagen. Esta instancia puede ser creada, iniciada, detenida, movida o eliminada a trav\u00e9s del cliente de Docker o de la API. Las instancias se pueden conectar a una o m\u00e1s redes, sistemas de almacenamiento, o incluso se puede crear una imagen a partir del estado de un contenedor. Se puede controlar c\u00f3mo de aislado est\u00e1 el contenedor del sistema anfitri\u00f3n y del resto de contenedores. El contenedor est\u00e1 definido tanto por la imagen de la que procede como de las opciones de configuraci\u00f3n que permita. Por ejemplo, la imagen oficial de MariaDb permite configurar a trav\u00e9s de opciones la contrase\u00f1a del administrador, de la primera base de datos que se cree, del usuario que la maneja, etc. Servicios (services) Los servicios permiten escalar contenedor a trav\u00e9s de m\u00faltiples demonios de Docker, los cuales trabajar\u00e1n conjuntamente como un enjambre (swarm). Objetivos del taller \u00b6 En este taller aprenderemos: A usar el registro oficial de Docker, a descargar y usar im\u00e1genes del mismo creando contenedores que nos puedan ser \u00fatiles. A crear una imagen a partir de otra. A automatizar la creaci\u00f3n de un conjunto de contenedores que interaccionan entre s\u00ed. En este taller no aprenderemos: A crear un cluster con Docker (Docker Swarm). A administrar sistemas. Se dar\u00e1n ya las instrucciones necesarias para crear servicios pero explicarlos est\u00e1 m\u00e1s alla del \u00e1mbito de este taller. Se recomienda cursar la asignatura: \"Programaci\u00f3n y Administraci\u00f3n de Sistemas\" del Grado de Ingenier\u00eda Inform\u00e1tica. Wikipedia: https://es.wikipedia.org/wiki/Docker_(software) \u21a9 Official Docker Documentation: Docker overview . \u21a9","title":"Introducci\u00f3n"},{"location":"introduction/#introduccion","text":"Seg\u00fan la Wikipedia: \"Docker es un proyecto de c\u00f3digo abierto que automatiza el despliegue de aplicaciones dentro de contenedores de software, proporcionando una capa adicional de abstracci\u00f3n y automatizaci\u00f3n de virtualizaci\u00f3n de aplicaciones en m\u00faltiples sistemas operativos. Docker utiliza caracter\u00edsticas de aislamiento de recursos del kernel Linux, tales como cgroups y espacios de nombres (namespaces) para permitir que 'contenedores' independientes se ejecuten dentro de una sola instancia de Linux, evitando la sobrecarga de iniciar y mantener m\u00e1quinas virtuales.\" 1 . Esto es una descripci\u00f3n formal, pero para enterarte de qu\u00e9 es docker sigue leyendo:","title":"Introducci\u00f3n"},{"location":"introduction/#a-quien-le-puede-interesar-usar-docker","text":"Docker es \u00fatil a administradores de sistemas, pero tambi\u00e9n a desarrolladores. Uno de los problemas que se presentan durante el desarrollo y despliegue de aplicaciones es encontrarnos con sistemas heterog\u00e9neos, no ya entre los desarrolladores, tambi\u00e9n entre los sistemas de pruebas, pre-producci\u00f3n y producci\u00f3n. Es decir, que los desarrolladores y los sistemas donde se ejecuta la aplicaci\u00f3n tienen librer\u00edas y sistemas operativos diferentes. \u00bfY por qu\u00e9 es un problema? Pues porque la aplicaci\u00f3n puede funcionar bien en una distribuci\u00f3n de GNU/Linux pero no bien en otra, o ejecutarse bien con la versi\u00f3n de un lenguaje pero no con otra. Para asegurar la calidad de desarrollo tenemos que asegurar que todo el mundo usa las mismas versiones de todas las aplicaciones y librer\u00edas necesarios. Esto es m\u00e1s complicado de lo que parece, porque hay desarrolladores que prefieron una distribuci\u00f3n concreta, o incluso sistemas privativos. Incluso los sistemas de pruebas, pre-producci\u00f3n y producci\u00f3n suelen ser distintos. Los sistemas de producci\u00f3n suelen ser m\u00e1s nuevos y potentes y los antiguos se dejan para pruebas y pre-producci\u00f3n. Otro problema es que un mismo desarrollador o un mismo sistema de despliegue tenga que trabajar en m\u00e1s de un proyecto que requiera versiones distintas de librer\u00edas, complic\u00e1ndolo a\u00fan m\u00e1s. Docker viene a solucionar todos estos problemas, tanto para los desarrolladores como para los administradores de sistemas. Con Docker podemos crear entornos aislados con configuraciones que ser\u00e1n exactamente igual siempre.","title":"\u00bfA qui\u00e9n le puede interesar usar docker?"},{"location":"introduction/#docker-es-virtualizacion","text":"En GNU/Linux Docker no es virtualizado, no hay un hipervisor. Los procesos que corren dentro de un contenedor de docker se ejecutan con el mismo kernel que la m\u00e1quina anfitri\u00f3n. Linux lo que hace es aislar esos procesos del resto de procesos del sistema, ya sean los propios de la m\u00e1quina anfitri\u00f3n o procesos de otros contenedores. Adem\u00e1s, es capaz de controlar los recursos que se le asignan a esos contenedores (cpu, memoria, red, etc.). Internamente, el contenedor no sabe que lo es y a todos los efectos es una distribuci\u00f3n GNU/Linux independiente, pero sin la penalizaci\u00f3n de rendimiento que tienen los sistemas virtualizados. As\u00ed que, cuando ejecutamos un contenedor, estamos ejecutando un servicio dentro de una distribuci\u00f3n construida a partir de una \"receta\". Esa receta permite que el sistema que se ejecuta sea siempre el mismo, independientemente de si estamos usando Docker en Ubuntu, Fedora o, incluso, sistemas privativos compatibles con Docker. De esa manera podemos garantizar que estamos desarrollando o desplegando nuestra aplicaci\u00f3n, siempre con la misma versi\u00f3n de todas las dependencias. Obviamente, si ejecutamos contenedores GNU/Linux dentro de sistemas privativos, s\u00ed habr\u00e1 virtualizaci\u00f3n.","title":"\u00bfDocker es virtualizaci\u00f3n?"},{"location":"introduction/#conceptos-basicos","text":"Antes de comenzar a instalar y usar docker es importante tener una serie de conceptos claros 2 : Demonio de docker (docker daemon) Es el proceso principal de docker. Escucha peticiones a la API y maneja los objetos de docker: im\u00e1genes, contenedores, redes, vol\u00famenes. Tambi\u00e9n es capaz de comunicarse con otros demonios para controlar servicios docker. Cliente de docker (docker client) Es la principal herramienta que usan los administradores de sistema para interaccionar con el sistema Docker. Registro de docker (docker registry) Es el lugar donde se almacenan las im\u00e1genes de Docker y poder descargarlas para reutilizarlas. Docker Hub es el principal registro p\u00fablico de Docker y contiene ya un mont\u00f3n de im\u00e1genes listas para ser usadas de multitud de servicios (mysql, wordpress, etc).","title":"Conceptos b\u00e1sicos"},{"location":"introduction/#objetos-de-docker","text":"Cuando usamos Docker, estamos creando y usando im\u00e1genes, contenedores, redes o vol\u00famenes, entre otros. A todo esto se le denominan objetos. Veamos los m\u00e1s importantes: Imagen (image) Plantilla de solo lectura que contiene las instrucciones para crear un contenedor Docker. Pueden estar basadas en otras imagenes, lo cual es habitual. Contenedor (container) Es una instancia ejecutable de una imagen. Esta instancia puede ser creada, iniciada, detenida, movida o eliminada a trav\u00e9s del cliente de Docker o de la API. Las instancias se pueden conectar a una o m\u00e1s redes, sistemas de almacenamiento, o incluso se puede crear una imagen a partir del estado de un contenedor. Se puede controlar c\u00f3mo de aislado est\u00e1 el contenedor del sistema anfitri\u00f3n y del resto de contenedores. El contenedor est\u00e1 definido tanto por la imagen de la que procede como de las opciones de configuraci\u00f3n que permita. Por ejemplo, la imagen oficial de MariaDb permite configurar a trav\u00e9s de opciones la contrase\u00f1a del administrador, de la primera base de datos que se cree, del usuario que la maneja, etc. Servicios (services) Los servicios permiten escalar contenedor a trav\u00e9s de m\u00faltiples demonios de Docker, los cuales trabajar\u00e1n conjuntamente como un enjambre (swarm).","title":"Objetos de docker"},{"location":"introduction/#objetivos-del-taller","text":"En este taller aprenderemos: A usar el registro oficial de Docker, a descargar y usar im\u00e1genes del mismo creando contenedores que nos puedan ser \u00fatiles. A crear una imagen a partir de otra. A automatizar la creaci\u00f3n de un conjunto de contenedores que interaccionan entre s\u00ed. En este taller no aprenderemos: A crear un cluster con Docker (Docker Swarm). A administrar sistemas. Se dar\u00e1n ya las instrucciones necesarias para crear servicios pero explicarlos est\u00e1 m\u00e1s alla del \u00e1mbito de este taller. Se recomienda cursar la asignatura: \"Programaci\u00f3n y Administraci\u00f3n de Sistemas\" del Grado de Ingenier\u00eda Inform\u00e1tica. Wikipedia: https://es.wikipedia.org/wiki/Docker_(software) \u21a9 Official Docker Documentation: Docker overview . \u21a9","title":"Objetivos del taller"},{"location":"tips/","text":"Trucos \u00b6 Portainer \u00b6 Portainer es una gestor de contenedores a trav\u00e9s de una interfaz web. Para usarlo creamos un directorio donde guardar nuestro docker-compose.yaml . mkdir -p ~/Sites/portainer cd ~/Sites/portainer Guardamos el siguiente fichero como docker-compose.yaml en nuestro directorio: version : '2' services : portainer : image : portainer/portainer command : -H unix:///var/run/docker.sock volumes : - /var/run/docker.sock:/var/run/docker.sock - portainer_data:/data ports : - 127.0.0.1:9000:9000 volumes : portainer_data : Y ejecutamos el contenedor: docker-compose up -d Limpieza \u00b6 Para borrar objetos que no est\u00e1n en uso: docker system prune Para borrar vol\u00famenes que no est\u00e1n asociados a ning\u00fan contenedor: docker volume rm $(docker volume ls -q -f \"dangling=true\") Para borrar contenedores que han terminado su ejecuci\u00f3n: docker rm $(docker ps -q -f \"status=exited\") Para borrar im\u00e1genes que no est\u00e1n etiquetadas: docker rmi $(docker images -q -f \"dangling=true\") Copias de seguridad \u00b6 Para hacer una copia de seguridad: docker run --rm -v /tmp:/backup \\ --volumes-from <container-name> \\ busybox tar -cvf /backup/backup.tar <path-to-data> Para restaurar: docker run --rm -v /tmp:/backup \\ --volumes-from <container-name> busybox tar -xvf /backup/backup.tar <path-to-data> Fuentes de esta p\u00e1gina: \u00b6 https://codefresh.io/docker-tutorial/everyday-hacks-docker/ http://blog.labianchin.me/2016/02/15/docker-tips-and-tricks Im\u00e1genes base \u00b6 Son las im\u00e1genes m\u00e1s conocidas por las que podemos usar para no partir desde cero para crear la nuestra. phusion/baseimage : 209mb centos : 200mb debian : 101mb ubuntu : 84mb alpine : 4.4mb busybox : 1.16mb","title":"Trucos"},{"location":"tips/#trucos","text":"","title":"Trucos"},{"location":"tips/#portainer","text":"Portainer es una gestor de contenedores a trav\u00e9s de una interfaz web. Para usarlo creamos un directorio donde guardar nuestro docker-compose.yaml . mkdir -p ~/Sites/portainer cd ~/Sites/portainer Guardamos el siguiente fichero como docker-compose.yaml en nuestro directorio: version : '2' services : portainer : image : portainer/portainer command : -H unix:///var/run/docker.sock volumes : - /var/run/docker.sock:/var/run/docker.sock - portainer_data:/data ports : - 127.0.0.1:9000:9000 volumes : portainer_data : Y ejecutamos el contenedor: docker-compose up -d","title":"Portainer"},{"location":"tips/#limpieza","text":"Para borrar objetos que no est\u00e1n en uso: docker system prune Para borrar vol\u00famenes que no est\u00e1n asociados a ning\u00fan contenedor: docker volume rm $(docker volume ls -q -f \"dangling=true\") Para borrar contenedores que han terminado su ejecuci\u00f3n: docker rm $(docker ps -q -f \"status=exited\") Para borrar im\u00e1genes que no est\u00e1n etiquetadas: docker rmi $(docker images -q -f \"dangling=true\")","title":"Limpieza"},{"location":"tips/#copias-de-seguridad","text":"Para hacer una copia de seguridad: docker run --rm -v /tmp:/backup \\ --volumes-from <container-name> \\ busybox tar -cvf /backup/backup.tar <path-to-data> Para restaurar: docker run --rm -v /tmp:/backup \\ --volumes-from <container-name> busybox tar -xvf /backup/backup.tar <path-to-data>","title":"Copias de seguridad"},{"location":"tips/#fuentes-de-esta-pagina","text":"https://codefresh.io/docker-tutorial/everyday-hacks-docker/ http://blog.labianchin.me/2016/02/15/docker-tips-and-tricks","title":"Fuentes de esta p\u00e1gina:"},{"location":"tips/#imagenes-base","text":"Son las im\u00e1genes m\u00e1s conocidas por las que podemos usar para no partir desde cero para crear la nuestra. phusion/baseimage : 209mb centos : 200mb debian : 101mb ubuntu : 84mb alpine : 4.4mb busybox : 1.16mb","title":"Im\u00e1genes base"},{"location":"wordpress/","text":"Levantar un WordPress con Docker \u00b6 Para crear un blog con WordPress necesitamos tener una base de datos d\u00f3nde almacenar las entradas. As\u00ed que empezaremos cre\u00e1ndola y despu\u00e9s crearemos el contenedor de nuestro blog . Crear un contenedor con MariaDB . \u00b6 WordPress soporta los motores relaciones MySQL y MariaDB . Usaremos este \u00faltimo. Example Vamos a crear nuestra base de datos usando este volumen. docker run -d --name wordpress-db \\ --mount source=wordpress-db,target=/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=secret \\ -e MYSQL_DATABASE=wordpress \\ -e MYSQL_USER=manager \\ -e MYSQL_PASSWORD=secret mariadb:10.3.9 La imagen se descargar\u00e1, si no lo estaba ya, y se iniciar\u00e1 nuestro contenedor de MariaDB : $ docker run -d --name wordpress-db \\ --mount source = wordpress-db,target = /var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD = secret \\ -e MYSQL_DATABASE = wordpress \\ -e MYSQL_USER = manager \\ -e MYSQL_PASSWORD = secret mariadb:10.3.9 Unable to find image 'mariadb:10.3.9' locally 10.3.9: Pulling from library/mariadb 124c757242f8: Pull complete 9d866f8bde2a: Pull complete fa3f2f277e67: Pull complete 398d32b153e8: Pull complete afde35469481: Pull complete 31f2ae82b3e3: Pull complete 3eeaf7e45ea6: Pull complete 716982328e17: Pull complete 34ce605c9036: Pull complete 4502ed9073c0: Pull complete 2afafbdf5a96: Pull complete 43d52b11dd31: Pull complete 30c7b70556f3: Pull complete 8b1b39f2f89a: Pull complete 41480b9319d7: Pull complete Digest: sha256:b7894bd08e5752acdd41fea654cb89467c99e67b8293975bb5d787b27e66ce1a Status: Downloaded newer image for mariadb:10.3.9 30634831d17108aa553a5774e27f398760bdbdf32debc3179843e73aa5957956 $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 30634831d171 mariadb:10.3.9 \"docker-entrypoint.s\u2026\" 20 seconds ago Up 16 seconds 3306/tcp wordpress-db El principal cambio en docker run con respecto a la \u00faltima vez es que no hemos usado -p (el par\u00e1metro para publicar puertos) y hemos a\u00f1adido el par\u00e1metro -d . Lo primero que habremos notado es que el contenedor ya no se queda en primer plano. El par\u00e1metro -d indica que debe ejecutarse como un proceso en segundo plano. As\u00ed no podremos pararlo por accidente con Control+C . Lo segundo es que vemos que el contenedor usa un puerto, el 3306/tcp , pero no est\u00e1 linkado a la m\u00e1quina anfitri\u00f3n. No tenemos forma de acceder a la base de datos directamente. Nuestra intenci\u00f3n es que solo el contenedor de WordPress pueda acceder. Luego una serie de par\u00e1metros -e que nos permite configurar nuestra base de datos. Info Los contenedores se configuran a trav\u00e9s de variables de ambiente, que podemos configurar con el par\u00e1metro -e que vemos en la orden anterior. Gracias a ellos hemos creado una base de datos, un usuario y configurado las contrase\u00f1as. Se recomienda buscar en el registro de Docker la imagen oficial de MariaDB para entender el uso de los par\u00e1metros. Por \u00faltimo, el par\u00e1metro --mount nos permite enlazar el volumen que creamos en el paso anterior con el directorio /var/lib/mysql del contenedor. Ese directorio es donde se guardan los datos de MariaDB . Eso significa que si borramos el contenedor, o actualizamos el contenedor a una nueva versi\u00f3n, no perderemos los datos porque ya no se encuentran en \u00e9l, si no en el volumen. Solo lo perder\u00edamos si borramos expl\u00edcitamente el volumen. Warning Cada contendor que usemos tendr\u00e1 uno o varios directorios donde se deben guardar los datos no vol\u00e1tiles. Nos corresponde a nosotros conocer la herramienta y saber de qu\u00e9 directorios se tratan. Usualmente est\u00e1n en la documentaci\u00f3n del contenedor, pero no siempre. Info El par\u00e1metro --mount se empez\u00f3 a utilizar desde la versi\u00f3n 17.06 para contenedores independientes (los que no pertenecen a un enjambre o swarm ). Los que conozcan Docker de versiones m\u00e1s antiguas estar\u00e1n m\u00e1s acostumbrados a usar el par\u00e1metro --volume que hace algo similar. Sin embargo la documentaci\u00f3n aconseja usar ya --mount , sobre todo para nuevos usuarios. Nosotros somos muy obedientes as\u00ed que en este taller usaremos --mount . Creando nuestro blog \u00b6 Vamos a crear otra vez nuestro contenedor de WordPress , pero esta vez vamos a conectarlo con nuestra base de datos. Adem\u00e1s, queremos poder editar los ficheros de las plantillas, por si tenemos que modificar algo, as\u00ed que necesitaremos montar el directorio del contenedor donde est\u00e1 instalado WordPress con nuestra cuenta de usuario en la m\u00e1quina anfitri\u00f3n. Example Vamos a crear el espacio de trabajo: mkdir -p ~/Sites/wordpress/target && cd ~/Sites/wordpress Example Y dentro de este directorio arrancamos el contenedor: docker run -d --name wordpress \\ --link wordpress-db:mysql \\ --mount type=bind,source=\"$(pwd)\"/target,target=/var/www/html \\ -e WORDPRESS_DB_USER=manager \\ -e WORDPRESS_DB_PASSWORD=secret \\ -p 8080:80 \\ wordpress:4.9.8 Cuando termine la ejecuci\u00f3n, si accedemos a la direcci\u00f3n http://localhost:8080/ , ahora s\u00ed podremos acabar el proceso de instalaci\u00f3n de nuestro WordPress. Si listamos el directorio target comprobaremos que tenemos todos los archivos de instalaci\u00f3n accesibles desde el directorio anfitri\u00f3n. Note Ejercicios: Para los contenedores, tanto el de WordPress como el MariaDB . Borra ambos. Vuelve a crearlos y mira como ya no es necesario volver a instalar WordPress . Vuelve a borrarlos y borra tambi\u00e9n el volumen. Vuelve a crear el volumen y los contenedores y comprueba que ahora s\u00ed hay que volver a instalar WordPress .","title":"Levantar un WordPress con Docker"},{"location":"wordpress/#levantar-un-wordpress-con-docker","text":"Para crear un blog con WordPress necesitamos tener una base de datos d\u00f3nde almacenar las entradas. As\u00ed que empezaremos cre\u00e1ndola y despu\u00e9s crearemos el contenedor de nuestro blog .","title":"Levantar un WordPress con Docker"},{"location":"wordpress/#crear-un-contenedor-con-mariadb","text":"WordPress soporta los motores relaciones MySQL y MariaDB . Usaremos este \u00faltimo. Example Vamos a crear nuestra base de datos usando este volumen. docker run -d --name wordpress-db \\ --mount source=wordpress-db,target=/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=secret \\ -e MYSQL_DATABASE=wordpress \\ -e MYSQL_USER=manager \\ -e MYSQL_PASSWORD=secret mariadb:10.3.9 La imagen se descargar\u00e1, si no lo estaba ya, y se iniciar\u00e1 nuestro contenedor de MariaDB : $ docker run -d --name wordpress-db \\ --mount source = wordpress-db,target = /var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD = secret \\ -e MYSQL_DATABASE = wordpress \\ -e MYSQL_USER = manager \\ -e MYSQL_PASSWORD = secret mariadb:10.3.9 Unable to find image 'mariadb:10.3.9' locally 10.3.9: Pulling from library/mariadb 124c757242f8: Pull complete 9d866f8bde2a: Pull complete fa3f2f277e67: Pull complete 398d32b153e8: Pull complete afde35469481: Pull complete 31f2ae82b3e3: Pull complete 3eeaf7e45ea6: Pull complete 716982328e17: Pull complete 34ce605c9036: Pull complete 4502ed9073c0: Pull complete 2afafbdf5a96: Pull complete 43d52b11dd31: Pull complete 30c7b70556f3: Pull complete 8b1b39f2f89a: Pull complete 41480b9319d7: Pull complete Digest: sha256:b7894bd08e5752acdd41fea654cb89467c99e67b8293975bb5d787b27e66ce1a Status: Downloaded newer image for mariadb:10.3.9 30634831d17108aa553a5774e27f398760bdbdf32debc3179843e73aa5957956 $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 30634831d171 mariadb:10.3.9 \"docker-entrypoint.s\u2026\" 20 seconds ago Up 16 seconds 3306/tcp wordpress-db El principal cambio en docker run con respecto a la \u00faltima vez es que no hemos usado -p (el par\u00e1metro para publicar puertos) y hemos a\u00f1adido el par\u00e1metro -d . Lo primero que habremos notado es que el contenedor ya no se queda en primer plano. El par\u00e1metro -d indica que debe ejecutarse como un proceso en segundo plano. As\u00ed no podremos pararlo por accidente con Control+C . Lo segundo es que vemos que el contenedor usa un puerto, el 3306/tcp , pero no est\u00e1 linkado a la m\u00e1quina anfitri\u00f3n. No tenemos forma de acceder a la base de datos directamente. Nuestra intenci\u00f3n es que solo el contenedor de WordPress pueda acceder. Luego una serie de par\u00e1metros -e que nos permite configurar nuestra base de datos. Info Los contenedores se configuran a trav\u00e9s de variables de ambiente, que podemos configurar con el par\u00e1metro -e que vemos en la orden anterior. Gracias a ellos hemos creado una base de datos, un usuario y configurado las contrase\u00f1as. Se recomienda buscar en el registro de Docker la imagen oficial de MariaDB para entender el uso de los par\u00e1metros. Por \u00faltimo, el par\u00e1metro --mount nos permite enlazar el volumen que creamos en el paso anterior con el directorio /var/lib/mysql del contenedor. Ese directorio es donde se guardan los datos de MariaDB . Eso significa que si borramos el contenedor, o actualizamos el contenedor a una nueva versi\u00f3n, no perderemos los datos porque ya no se encuentran en \u00e9l, si no en el volumen. Solo lo perder\u00edamos si borramos expl\u00edcitamente el volumen. Warning Cada contendor que usemos tendr\u00e1 uno o varios directorios donde se deben guardar los datos no vol\u00e1tiles. Nos corresponde a nosotros conocer la herramienta y saber de qu\u00e9 directorios se tratan. Usualmente est\u00e1n en la documentaci\u00f3n del contenedor, pero no siempre. Info El par\u00e1metro --mount se empez\u00f3 a utilizar desde la versi\u00f3n 17.06 para contenedores independientes (los que no pertenecen a un enjambre o swarm ). Los que conozcan Docker de versiones m\u00e1s antiguas estar\u00e1n m\u00e1s acostumbrados a usar el par\u00e1metro --volume que hace algo similar. Sin embargo la documentaci\u00f3n aconseja usar ya --mount , sobre todo para nuevos usuarios. Nosotros somos muy obedientes as\u00ed que en este taller usaremos --mount .","title":"Crear un contenedor con MariaDB."},{"location":"wordpress/#creando-nuestro-blog","text":"Vamos a crear otra vez nuestro contenedor de WordPress , pero esta vez vamos a conectarlo con nuestra base de datos. Adem\u00e1s, queremos poder editar los ficheros de las plantillas, por si tenemos que modificar algo, as\u00ed que necesitaremos montar el directorio del contenedor donde est\u00e1 instalado WordPress con nuestra cuenta de usuario en la m\u00e1quina anfitri\u00f3n. Example Vamos a crear el espacio de trabajo: mkdir -p ~/Sites/wordpress/target && cd ~/Sites/wordpress Example Y dentro de este directorio arrancamos el contenedor: docker run -d --name wordpress \\ --link wordpress-db:mysql \\ --mount type=bind,source=\"$(pwd)\"/target,target=/var/www/html \\ -e WORDPRESS_DB_USER=manager \\ -e WORDPRESS_DB_PASSWORD=secret \\ -p 8080:80 \\ wordpress:4.9.8 Cuando termine la ejecuci\u00f3n, si accedemos a la direcci\u00f3n http://localhost:8080/ , ahora s\u00ed podremos acabar el proceso de instalaci\u00f3n de nuestro WordPress. Si listamos el directorio target comprobaremos que tenemos todos los archivos de instalaci\u00f3n accesibles desde el directorio anfitri\u00f3n. Note Ejercicios: Para los contenedores, tanto el de WordPress como el MariaDB . Borra ambos. Vuelve a crearlos y mira como ya no es necesario volver a instalar WordPress . Vuelve a borrarlos y borra tambi\u00e9n el volumen. Vuelve a crear el volumen y los contenedores y comprueba que ahora s\u00ed hay que volver a instalar WordPress .","title":"Creando nuestro blog"}]}